<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Archivo de las Salas ‚Äì Prototipo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #0f1115;
      --bg-elevated: #181b22;
      --accent: #e0b66b;
      --accent-soft: rgba(224, 182, 107, 0.15);
      --text: #f5f5f5;
      --muted: #a0a4b3;
      --danger: #ff6b6b;
      --radius-lg: 18px;
      --radius-xl: 26px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
	.home {
	  display: flex;
	  flex-direction: column;
	  gap: 10px;
	  align-items: flex-start;
	  justify-content: center;
	  min-height: 260px;
	  padding: 10px 4px 6px;
	}

	.home-title {
	  font-size: 2rem;
	  letter-spacing: 0.18em;
	  text-transform: uppercase;
	  color: var(--accent);
	}

	.home-subtitle {
	  font-size: 0.95rem;
	  color: var(--muted);
	}

	.home-text {
	  font-size: 0.9rem;
	  color: #e4e7f2;
	  max-width: 520px;
	}

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: radial-gradient(circle at top,
              #4b3a26 0,
              #2b2117 45%,
              #120d08 100%);
      color: #f5f0e6;
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      display: flex;
      
      position: relative;
width: 100%;
      max-width: 1200px;
      margin: 16px;
      background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(0,0,0,0.8));
      border-radius: 32px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow:
        0 24px 80px rgba(0,0,0,0.8),
        0 0 0 1px rgba(255,255,255,0.02);
    }

    /* SIDEBAR */

    .sidebar {
      width: 260px;
      background: rgba(0,0,0,0.85);
      border-right: 1px solid rgba(255,255,255,0.06);
      padding: 20px 18px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .logo {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .logo-title {
      font-size: 1.1rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
    }

    .logo-subtitle {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .room-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .room-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .room-btn {
      width: 100%;
      text-align: left;
      padding: 9px 10px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text);
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.18s ease-out;
    }

    .room-btn span.icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 20%, var(--accent), transparent 60%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      opacity: 0.85;
    }

    .room-btn small {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .room-btn strong {
      display: block;
    }

    .room-btn:hover {
      background: rgba(255,255,255,0.03);
      border-color: rgba(255,255,255,0.08);
      transform: translateY(-1px);
    }

    .room-btn.active {
      background: var(--accent-soft);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.6);
    }

    .sidebar-footer {
      margin-top: auto;
      font-size: 0.75rem;
      color: var(--muted);
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 10px;
    }

    /* MAIN */

    .main {
      flex: 1;
      padding: 20px 22px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .room-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .room-header-left h2 {
      font-size: 1.4rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .room-header-left p {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .progress {
      font-size: 0.8rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .progress-bar {
      flex: 1;
      min-width: 120px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #ffffff);
      transition: width 0.25s ease-out;
    }

	.image-section {
	  display: flex;
	  flex-direction: column;
	  gap: 8px;
	}

	.image-frame {
	  width: 100%;
	  aspect-ratio: 16 / 10.5;
	  max-height: none;
	  border-radius: var(--radius-xl);
	  overflow: hidden;
	  background: radial-gradient(circle at top, rgba(255,255,255,0.06), rgba(0,0,0,0.9));
	  border: 1px solid rgba(255,255,255,0.06);
	  display: flex;
	  align-items: center;
	  justify-content: center;
	}

	.image-frame img {
	  width: 100%;
	  height: 100%;
	  object-fit: cover;   /* importante cuando todas tengan 16:9 */
	  display: block;
	}

    .tagline {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .audio-box {
      padding: 10px 12px;
      border-radius: var(--radius-lg);
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 0.8rem;
    }

    .audio-box audio {
		display: none; /* el reproductor no se ve, solo suena */
    }

	.puzzle-card {
	  background: rgba(27, 20, 12, 0.95);
	  border-color: rgba(255, 240, 200, 0.18);
	}


    .puzzle-meta {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      flex-wrap: wrap;
    }

    .puzzle-meta-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #puzzleTitle {
      font-size: 1.1rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
    }

    .pill span.dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--accent);
    }

    .puzzle-body {
      font-size: 0.9rem;
      line-height: 1.5;
      color: #e4e7f2;
      white-space: pre-line;
    }

    .badge-bible {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(102, 187, 106, 0.12);
      border: 1px solid rgba(102, 187, 106, 0.6);
      color: #d0ffd5;
    }

    .badge-bible svg {
      width: 14px;
      height: 14px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    button.action {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.5);
      color: var(--text);
      font-size: 0.85rem;
      padding: 7px 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s ease-out;
    }

    button.action.primary {
      background: linear-gradient(135deg, var(--accent), #ffffff);
      color: #161616;
      font-weight: 600;
      border-color: transparent;
    }

    button.action:disabled {
      opacity: 0.45;
      cursor: default;
    }

    button.action:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(0,0,0,0.6);
    }

    .reveal {
      font-size: 0.85rem;
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.55);
      border: 1px dashed rgba(255,255,255,0.18);
      margin-top: 4px;
      display: none;
      white-space: pre-line;
    }

    .reveal.visible {
      display: block;
    }

    @media (max-width: 950px) {
      .app {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        flex-direction: row;
        overflow-x: auto;
        padding-bottom: 10px;
      }

      .room-list {
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 6px;
        margin-left: auto;
      }

      .sidebar-footer {
        display: none;
      }

      .media {
        grid-template-columns: 1fr;
      }

      .image-frame {
        min-height: 180px;
      }
    }

    @media (max-width: 600px) {
      .puzzle-card {
        padding: 14px;
      }

      .room-header {
        flex-direction: column;
        align-items: flex-start;
      }
    }

	/* Modo portada: sin men√∫ lateral */
	.app
  /* --- Layout tweaks: centrar campa√±a/QR y justificar texto --- */
  .booting .main > section,
  .booting .main > .room-view { display: none !important; }

  /* Centrado de pantallas "sin tablero" (campa√±a setup + QR) */
  .campaign-setup,
  #campaignJoinSection,
  #playerSection {
    max-width: 900px;
    margin: 0 auto;
  }
  .campaign-form,
  #campaignJoinSection .roles-grid,
  #playerSection .roles-grid {
    margin-left: auto;
    margin-right: auto;
  }

  /* Texto justificado (portada + reglas + textos auxiliares) */
  .home-text,
  .rules-text {
    text-align: justify;
    hyphens: auto;
  }


.rules p, .rules li {
  text-align: justify;
  hyphens: auto;
}
.home-mode .sidebar {
	  display: none;
	}

	.app.home-mode .main {
	  margin: 0 auto;
	  max-width: 900px;
	}

	/* Portada m√°s ‚Äú√©pica manuscrito‚Äù */
	.home {
	  display: flex;
	  flex-direction: column;
	  gap: 14px;
	  align-items: flex-start;
	  justify-content: center;
	  min-height: 320px;
	  padding: 24px 8px 16px;
	}

	.home-title {
	  font-size: 2.4rem;
	  letter-spacing: 0.22em;
	  text-transform: uppercase;
	  color: var(--accent);
	}

	.home-subtitle {
	  font-size: 1rem;
	  color: var(--muted);
	}

	.home-text {
	  font-size: 0.95rem;
	  color: #f3e7d6;
	  max-width: 620px;
	}
	/* Portada */

	.home {
	  display: flex;
	  flex-direction: column;
	  gap: 14px;
	  align-items: flex-start;
	  justify-content: center;
	  min-height: 320px;
	  padding: 24px 8px 16px;
	}

	.home-title {
	  font-size: 2.4rem;
	  letter-spacing: 0.22em;
	  text-transform: uppercase;
	  color: var(--accent);
	}

	.home-subtitle {
	  font-size: 1rem;
	  color: var(--muted);
	}

	.home-heading {
	  font-size: 1rem;
	  text-transform: uppercase;
	  letter-spacing: 0.14em;
	  margin-top: 6px;
	  color: var(--accent);
	}

	.home-text {
	  font-size: 0.95rem;
	  color: #f3e7d6;
	  max-width: 650px;
	}

	.home-list {
	  margin-left: 1.2rem;
	  display: flex;
	  flex-direction: column;
	  gap: 6px;
	  font-size: 0.9rem;
	  color: #f3e7d6;
	  max-width: 650px;
	}

	.home-buttons {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 10px;
	  margin-top: 10px;
	}

	/* Bot√≥n secundario */

	button.action.secondary {
	  background: transparent;
	  border-color: rgba(255,255,255,0.35);
	  color: var(--text);
	  font-weight: 500;
	}

	button.action.secondary:hover {
	  background: rgba(255,255,255,0.06);
	}
	.rules {
	  display: flex;
	  flex-direction: column;
	  gap: 10px;
	  padding: 18px 4px 12px;
	  max-width: 920px;
  margin: 0 auto;
  }

	.rules-title {
	  font-size: 1.4rem;
	  letter-spacing: 0.16em;
	  text-transform: uppercase;
	  color: var(--accent);
	}

	.rules-heading {
	  font-size: 0.95rem;
	  text-transform: uppercase;
	  letter-spacing: 0.12em;
	  margin-top: 6px;
	  color: var(--accent);
	}

	.rules-text {
	  font-size: 0.9rem;
	  color: #f3e7d6;
	}

	.rules-list {
	  margin-left: 1.2rem;
	  display: flex;
	  flex-direction: column;
	  gap: 4px;
	  font-size: 0.9rem;
	  color: #f3e7d6;
	}

	/* En modo portada/reglas ocultamos la sidebar y centramos contenido */
	.app.home-mode .sidebar {
	  display: none;
	}

	.app.home-mode .main {
	  margin: 0 auto;
	  max-width: 900px;
	}
	
	.room-header {
	  display: flex;
	  justify-content: space-between;
	  align-items: flex-end;
	  gap: 16px;
	}

	.room-header-right {
	  display: flex;
	  flex-direction: column;
	  align-items: flex-end;
	  gap: 6px;
	}

	.puzzle-jump {
	  display: flex;
	  align-items: center;
	  gap: 6px;
	}

	.puzzle-jump input {
	  background: rgba(0, 0, 0, 0.4);
	  border: 1px solid rgba(255, 255, 255, 0.16);
	  border-radius: 999px;
	  padding: 4px 10px;
	  font-size: 0.75rem;
	  color: #f5f5f7;
	  width: 90px;
	}

	.puzzle-jump input::placeholder {
	  color: rgba(255, 255, 255, 0.4);
	  text-transform: uppercase;
	  letter-spacing: 0.15em;
	}

	button.action.small {
	  padding: 4px 10px;
	  font-size: 0.75rem;
	}

	.puzzle-code-message {
	  font-size: 0.75rem;
	  color: #f5e0b3;
	  min-height: 1em;
	}

	.puzzle-state {
	  font-size: 0.75rem;
	  text-transform: uppercase;
	  letter-spacing: 0.12em;
	  color: var(--muted);
	  margin-top: 2px;
	  display: inline-block;
	}

	.puzzle-card.solved {
	  border-color: rgba(120, 216, 150, 0.7);
	  box-shadow: 0 0 0 1px rgba(120, 216, 150, 0.35);
	}

	.puzzle-card.solved h3#puzzleTitle {
	  color: #78d896;
	}

	.puzzle-card.solved .pill {
	  border-color: rgba(120, 216, 150, 0.4);
	}

	/* bot√≥n secundario (si a√∫n no lo tienes) */
	button.action.secondary {
	  background: transparent;
	  border-color: rgba(255,255,255,0.35);
	  color: var(--text);
	  font-weight: 500;
	}
	button.action.secondary:hover {
	  background: rgba(255,255,255,0.06);
	}
	
	.room-meta {
	  display: flex;
	  flex-direction: column;
	  gap: 2px;
	}

	.room-progress {
	  font-size: 0.75rem;
	  opacity: 0.8;
	}

	.room-solved-summary {
	  display: block;
	  font-size: 0.8rem;
	  opacity: 0.8;
	  margin-top: 0.25rem;
	}

	.global-solved {
	  font-size: 0.8rem;
	  margin-bottom: 0.25rem;
	}

	/* Opcional: marcar visualmente acertijos resueltos */
	.puzzle-card.puzzle-solved {
	  border-color: #3b7f3b;
	  box-shadow: 0 0 0 1px rgba(59, 127, 59, 0.4);
	}

	#toggleSolvedBtn.solved {
	  background: #1f5a2f;
	  border-color: #1f5a2f;
	}
	
	button.action.secondary {
	  background: transparent;
	  border-color: rgba(255,255,255,0.35);
	  color: var(--text);
	}
	button.action.secondary:hover {
	  background: rgba(255,255,255,0.06);
	}
	
	.campaign-setup {
	  display: flex;
	  flex-direction: column;
	  gap: 12px;
	  max-width: 680px;
	  padding: 24px 8px 16px;
	}

	.campaign-form {
	  display: flex;
	  flex-direction: column;
	  gap: 10px;
	}

	.campaign-form label {
	  display: flex;
	  flex-direction: column;
	  gap: 4px;
	  font-size: 0.9rem;
	  color: #f3e7d6;
	}

	.campaign-form input {
	  background: #15110c;
	  border: 1px solid rgba(255,255,255,0.15);
	  border-radius: 999px;
	  padding: 6px 10px;
	  color: #f3e7d6;
	  font-size: 0.9rem;
	}

	.board-section {
	  display: flex;
	  flex-direction: column;
	  gap: 24px;
	  padding: 16px 8px;
	}

	/* El tablero ocupa todo el ancho disponible y los bloques
	   de jugadores pasan debajo */
	.board-layout {
	  display: flex;
	  flex-direction: column;
	  gap: 24px;
	  align-items: center;
	}

	/* Tablero cuadrado y centrado */
	.board-main {
	  position: relative;
	  width: 100%;
	  max-width: 950px;          /* ajusta si quieres m√°s o menos grande */
	  aspect-ratio: 1 / 1;       /* <- cuadrado */
	  border-radius: 18px;
	  overflow: hidden;
	  background: radial-gradient(circle at center, #2a2520, #120e0a);
	}

	/* La imagen rellena el cuadro */
	.board-image {
	  display: block;
	  width: 100%;
	  height: 100%;
	  object-fit: cover;         /* recorta si la imagen no es cuadrada */
	}

	/* Bloque de jugadores y c√≥digo, debajo del tablero */
	.board-sidebar {
	  width: 100%;
	  max-width: 950px;
	  display: flex;
	  flex-direction: column;
	  gap: 12px;
	}

	.players-summary {
	  display: flex;
	  flex-direction: column;
	  gap: 6px;
	  font-size: 0.9rem;
	  color: #f3e7d6;
	}

	.player-row {
	  padding: 6px 10px;
	  border-radius: 999px;
	  background: rgba(0,0,0,0.35);
	  display: flex;
	  flex-direction: column;
	  gap: 2px;
	}

	.player-row strong {
	  color: var(--accent);
	}

	.board-controls {
	  display: flex;
	  flex-direction: column;
	  gap: 6px;
	  margin-top: 6px;
	}

	.board-controls input {
	  background: #15110c;
	  border: 1px solid rgba(255,255,255,0.15);
	  border-radius: 999px;
	  padding: 6px 10px;
	  color: #f3e7d6;
	}
	
	.effect-card {
	  display: flex;
	  gap: 8px;
	  padding: 6px 8px;
	  border-radius: 12px;
	  background: rgba(0, 0, 0, 0.35);
	  align-items: flex-start;
	  margin-top: 4px;
	}

	.effect-card img {
	  width: 40px;
	  height: 40px;
	  object-fit: cover;
	  border-radius: 999px;
	  flex-shrink: 0;
	}

	.effect-title {
	  font-size: 0.85rem;
	  font-weight: 600;
	}

	.effect-tag {
	  font-size: 0.75rem;
	  opacity: 0.8;
	  margin-bottom: 2px;
	}

	.effect-desc {
	  font-size: 0.75rem;
	  line-height: 1.3;
	}

	.pecado-selector label {
	  font-size: 0.8rem;
	  margin-bottom: 4px;
	}

	.sin-select {
	  width: 100%;
	  background: #15110c;
	  border: 1px solid rgba(255,255,255,0.25);
	  border-radius: 999px;
	  padding: 4px 8px;
	  color: #f3e7d6;
	  font-size: 0.8rem;
	}

	.roles-grid {
	  display: grid;
	  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
	  gap: 1.25rem;
	  margin-top: 1.5rem;
	}

	.player-role-card {
	  background: rgba(0, 0, 0, 0.35);
	  border-radius: 16px;
	  padding: 1rem 1.25rem;
	  border: 1px solid rgba(255, 255, 255, 0.05);
	}

	.player-role-header {
	  font-weight: 600;
	  margin-bottom: 0.5rem;
	  color: var(--accent, #e0b66b);
	}

	.effect-card {
	  display: flex;
	  gap: 0.75rem;
	  margin-bottom: 0.75rem;
	}

	.effect-card img {
	  width: 70px;
	  height: 110px;
	  object-fit: cover;
	  border-radius: 8px;
	  border: 1px solid rgba(255, 255, 255, 0.1);
	}

	.effect-card-text h4 {
	  margin: 0;
	  font-size: 0.95rem;
	}

	.effect-card-text small {
	  display: block;
	  color: var(--muted, #a0a4b3);
	  margin-bottom: 0.25rem;
	}

	.effect-card-text p {
	  margin: 0;
	  font-size: 0.85rem;
	}

	.sins-grid {
	  display: grid;
	  grid-template-columns: repeat(2, minmax(0, 1fr));
	  gap: 0.5rem;
	}

	.sin-card {
	  display: flex;
	  align-items: flex-start;
	  gap: 0.5rem;
	  padding: 0.4rem 0.5rem;
	  border-radius: 10px;
	  border: 1px solid rgba(255, 255, 255, 0.08);
	  background: rgba(0, 0, 0, 0.25);
	  cursor: pointer;
	  text-align: left;
	}

	.sin-card img {
	  border-radius: 14px;
	  width: 100%;
	  height: auto;          /* deja que se ajuste seg√∫n el ancho */
	  max-height: 360px;     /* l√≠mite de altura para que no se dispare */
	  object-fit: contain;   /* encaja la imagen completa dentro del recuadro */
	}

	.sin-card.selected {
	  border-color: var(--accent, #e0b66b);
	  box-shadow: 0 0 0 1px rgba(224, 182, 107, 0.4);
	}

	.sin-card.disabled {
	  opacity: 0.35;
	  cursor: default;
	}

	.roles-actions {
	  margin-top: 1.5rem;
	  display: flex;
	  gap: 0.75rem;
	}

	/* ==== OVERLAY DE PECADOS ==== */

	.sin-overlay {
	  position: fixed;
	  inset: 0;
	  background: radial-gradient(circle at center, rgba(0,0,0,0.8), rgba(0,0,0,0.95));
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  z-index: 999;
	}

	.sin-overlay--hidden {
	  display: none;
	}

	.sin-overlay-inner {
	  background: rgba(15, 10, 5, 0.96);
	  border-radius: 24px;
	  border: 1px solid rgba(255, 214, 150, 0.25);
	  box-shadow: 0 24px 80px rgba(0, 0, 0, 0.8);
	  padding: 2.5rem 3rem;
	  width: min(1180px, 96vw);   /* ‚¨Ö m√°s ancho */
	  max-height: 90vh;
	  display: flex;
	  flex-direction: column;
	  gap: 1.75rem;
	  position: relative;
	}


	.sin-overlay-close {
	  position: absolute;
	  top: 0.75rem;
	  right: 0.9rem;
	  border: none;
	  background: transparent;
	  color: #f5f1e6;
	  font-size: 1.8rem;
	  cursor: pointer;
	  line-height: 1;
	}

	.sin-overlay-title {
	  font-size: 1.4rem;
	  letter-spacing: 0.08em;
	  text-transform: uppercase;
	  color: #f4d9a0;
	}

	.sin-overlay-subtitle {
	  font-size: 0.95rem;
	  color: rgba(245, 241, 230, 0.8);
	}

	/* Carrusel */

	.sin-carousel {
	  display: flex;
	  gap: 2rem;
	  overflow-x: auto;
	  padding-bottom: 0.9rem;
	  scroll-snap-type: x mandatory; /* efecto de ‚Äúencaje‚Äù al deslizar */
	}

	.sin-carousel::-webkit-scrollbar {
	  height: 6px;
	}
	.sin-carousel::-webkit-scrollbar-track {
	  background: transparent;
	}
	.sin-carousel::-webkit-scrollbar-thumb {
	  background: rgba(255, 214, 150, 0.3);
	  border-radius: 3px;
	}

	/* Carta de pecado */

	.sin-card {
	  min-width: 240px;              /* ‚¨Ö m√°s anchas */
	  max-width: 260px;
	  background: radial-gradient(circle at top, rgba(255,255,255,0.06), rgba(0,0,0,0.9));
	  border-radius: 20px;
	  border: 1px solid rgba(255,255,255,0.14);
	  padding: 1.1rem;
	  display: flex;
	  flex-direction: column;
	  gap: 0.7rem;
	  align-items: center;
	  scroll-snap-align: center;
	  cursor: pointer;
	  transition:
		transform 0.18s ease,
		box-shadow 0.18s ease,
		border-color 0.18s ease,
		opacity 0.18s ease;
	}

	.sin-card-title {
	  font-weight: 600;
	  letter-spacing: 0.06em;
	  text-transform: uppercase;
	  font-size: 0.85rem;
	}

	.sin-card-text {
	  font-size: 0.8rem;
	  color: rgba(245, 241, 230, 0.85);
	  text-align: center;
	}

	/* estados */

	.sin-card:hover {
	  transform: translateY(-4px);
	  border-color: rgba(255, 214, 150, 0.7);
	  box-shadow: 0 16px 40px rgba(0, 0, 0, 0.7);
	}

	.sin-card--selected {
	  border-color: rgba(255, 214, 150, 1);
	  box-shadow: 0 0 20px rgba(255, 214, 150, 0.8);
	}

	.sin-card--taken {
	  opacity: 0.25;
	  cursor: not-allowed;
	}

	.player-panel {
	  margin-bottom: 1.75rem;
	}

	.player-panel-title {
	  font-size: 1.05rem;
	  margin-bottom: 0.5rem;
	}

	.player-panel-inner {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 1rem;
	}

	.role-card {
	  flex: 1 1 260px;
	  background: radial-gradient(circle at top left, rgba(255,255,255,0.06), rgba(0,0,0,0.9));
	  border-radius: 16px;
	  border: 1px solid rgba(255,255,255,0.12);
	  padding: 1rem;
	}

	.role-card-label {
	  font-size: 0.75rem;
	  letter-spacing: 0.12em;
	  text-transform: uppercase;
	  opacity: 0.7;
	}

	.role-card-name {
	  font-weight: 600;
	  margin-top: 0.25rem;
	}

	.role-card-body {
	  display: flex;
	  gap: 0.75rem;
	  margin-top: 0.75rem;
	}

	.role-card-body img {
	  width: 80px;
	  height: auto;
	  border-radius: 10px;
	}

	.role-card-desc {
	  font-size: 0.85rem;
	  margin-top: 0.5rem;
	  color: rgba(245,241,230,0.9);
	}

	.player-panel-footer {
	  margin-top: 0.5rem;
	  font-size: 0.85rem;
	  opacity: 0.8;
	}
	
	/* Iconos CUADRADOS para los mandamientos */
	.role-card--commandment .role-card-body img {
	  width: 120px;
	  height: 120px;        /* mismo ancho y alto -> cuadrado */
	  object-fit: contain;  /* no deforma el dibujo */
	  border-radius: 10px;  /* opcional, para que quede suave */
	  display: block;
	}

	/* (Opcional) aseguramos que los pecados sigan siendo rectangulares */
	.role-card--sin .role-card-body img {
	  width: 90px;
	  height: auto;
	  object-fit: contain;
	}

		.global-music-toggle{
	  position: absolute; /* anclado al contenedor .app para que no ‚Äúflote‚Äù fuera */
	  top: 16px;
	  right: 16px;
	  z-index: 20000;
	  display: flex;
	  gap: 10px;
	  align-items: center;
	  pointer-events: auto;
	}

	.global-music-toggle .action.small {
	  font-size: 0.75rem;
	  padding: 4px 10px;
	  opacity: 0.85;
	}
	
	.room-music-toggle {
	  margin-bottom: 8px;
	  display: flex;
	  justify-content: flex-end;
	}

	  
/* --- Transiciones suaves entre pantallas (ARCHIVUM) --- */
:root{
  --archivum-tx-duration: 340ms;
  --archivum-tx-ease: cubic-bezier(.2,.8,.2,1);
}

#homeSection,
#campaignSetupSection,
#rulesSection,
#campaignJoinSection,
#playerSection,
#campaignRolesSection,
#campaignBoardSection,
#roomSection{
  opacity: 1;
  transition: opacity var(--archivum-tx-duration) var(--archivum-tx-ease);
  will-change: opacity;
}

.view-hidden{
  opacity: 0 !important;
  pointer-events: none !important;
}

.fade-pop{
  animation: archivumFadePop 420ms var(--archivum-tx-ease);
}
@keyframes archivumFadePop{
  from { opacity: 0; }
  to   { opacity: 1; }
}


/* Fade-to-black transition overlay */
.fade-overlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.92);
  opacity: 0;
  pointer-events: none;
  z-index: 10001;
  transition: opacity 240ms ease-in-out;
}
.fade-overlay.is-on{
  opacity: 1;
  pointer-events: all;
}

/* Ritual overlay (host / jugador) */
#ritualOverlay{
  position: fixed;
  inset: 0;
  z-index: 9999;
  display: none; /* se gestiona v√≠a JS */
  align-items: center;
  justify-content: center;
  padding: 24px;
  background:
    radial-gradient(circle at 50% 40%, rgba(0,0,0,.15), rgba(0,0,0,.78) 60%, rgba(0,0,0,.92) 100%);
  backdrop-filter: blur(2px);
}
#ritualOverlay.ritual-visible{
  display: flex;
}
#ritualCard{
  max-width: 720px;
  width: 100%;
  border: 1px solid rgba(210,175,110,.45);
  border-radius: 16px;
  padding: 20px 18px;
  background: rgba(10,8,6,.70);
  box-shadow: 0 18px 60px rgba(0,0,0,.55);
}
#ritualTitle{
  margin: 0 0 8px 0;
  font-size: 14px;
  letter-spacing: .22em;
  text-transform: uppercase;
  color: rgba(210,175,110,.95);
}
#ritualText{
  margin: 0;
  font-size: 18px;
  line-height: 1.45;
  color: rgba(245,235,210,.95);
}

@media (prefers-reduced-motion: reduce){
  #homeSection,
  #campaignSetupSection,
  #rulesSection,
  #campaignJoinSection,
  #playerSection,
  #campaignRolesSection,
  #campaignBoardSection,
  #roomSection{
    transition: none !important;
    transform: none !important;
  }
  .fade-pop{ animation: none !important; }
}


/* Modo jugador: ocultar controles de m√∫sica */
body.player-mode #globalMusicToggleContainer,
body.player-mode #roomMusicToggleContainer{ display:none !important; }

/* --- Respuesta final (campa√±a) --- */
.answer-bar{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
  margin-top:10px;
  padding-top:8px;
  border-top:1px solid rgba(255,255,255,0.10);
}
.answer-bar input{
  flex:1 1 220px;
  min-width:200px;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.18);
  background:rgba(0,0,0,0.25);
  color:inherit;
  outline:none;
}
.answer-bar input::placeholder{ opacity:0.7; }
.answer-feedback{
  width:100%;
  margin-top:6px;
  font-size:0.95rem;
  opacity:0.95;
}
.answer-feedback.ok{ color:#bfffc1; }
.answer-feedback.bad{ color:#ffbfbf; }


    /* Modal (m√≥vil): selector de objetivo para Pecado */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
    }
    .modal-card {
      width: min(520px, 100%);
      background: rgba(0,0,0,0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 22px;
      padding: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.7);
    }
    .modal-title {
      font-size: 1.05rem;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--accent);
    }
    .modal-subtitle {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.35;
    }
    .modal-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 14px;
    }
    .modal-target-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.03);
      color: var(--text);
      cursor: pointer;
      transition: all 0.16s ease-out;
      text-align: left;
    }
    .modal-target-btn:hover {
      background: var(--accent-soft);
      border-color: rgba(224,182,107,0.55);
      transform: translateY(-1px);
    }
    .modal-target-btn strong {
      font-size: 1rem;
    }
    .modal-target-btn small {
      display: block;
      color: var(--muted);
      font-size: 0.78rem;
      margin-top: 2px;
      letter-spacing: 0.04em;
    }
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
    }


    /* Reglas: acordeones de roles */
    .rules-detail{
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .rules-detail summary{
      cursor: pointer;
      list-style: none;
      outline: none;
      font-weight: 700;
    }
    .rules-detail summary::-webkit-details-marker{ display:none; }
    .rules-detail[open]{ background: rgba(255,255,255,0.06); }

/* ---------------------------
   C√≥dice: recompensa por sala
----------------------------*/
#codexRewardOverlay{
  position:fixed; inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.92);
  z-index:9999;
  padding:24px;
}
#codexRewardOverlay.show{ display:flex; }
#codexRewardCard{
  max-width:min(520px, 92vw);
  width:100%;
  text-align:center;
  transform:translateY(24px);
  opacity:0;
  transition:transform .55s ease, opacity .55s ease;
}
#codexRewardOverlay.show #codexRewardCard{
  transform:translateY(0);
  opacity:1;
}
#codexRewardImg{
  width:100%;
  height:auto;
  display:block;
  filter: drop-shadow(0 18px 30px rgba(0,0,0,.55));
}
#codexRewardHint{
  margin-top:14px;
  font-size:14px;
  opacity:.85;
}
#codexRewardBtn{
  margin-top:14px;
  padding:10px 14px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.06);
  color:#fff;
  cursor:pointer;
}
#codexRewardBtn:hover{ background:rgba(255,255,255,.10); }

</style>
</head>
<body>
  <div id="fadeOverlay" class="fade-overlay" aria-hidden="true"></div>
  
  <div class="app booting" id="appRoot">
    
  <!-- Bot√≥n global de m√∫sica (siempre visible) -->
  <div class="global-music-toggle" id="globalMusicToggleContainer">
    <button id="musicToggleBtn" class="action secondary small" type="button">üîä M√∫sica General: ON</button>
  </div>
<aside class="sidebar" style="display:none;">
		<div class="logo" id="homeLogo" style="cursor:pointer;">
		  <div class="logo-title">ARCHIVUM</div>
		  <div class="logo-subtitle">Salas y acertijos b√≠blicos</div>
		</div>
      <div class="room-list-wrapper">
        <div class="room-label">Salas</div>
        <div class="room-list">
			<button class="room-btn active" data-room="origen">
			  <span class="icon">Œ±</span>
			  <div class="room-meta">
				<small>1 ¬∑ G√©nesis</small>
				<strong>Sala del Origen</strong>
				<span class="room-progress" data-room-counter="origen">0/0</span>
			  </div>
			</button>

			<button class="room-btn" data-room="promesa">
			  <span class="icon">‚ú∂</span>
			  <div class="room-meta">
				<small>2 ¬∑ Patriarcas</small>
				<strong>Sala de la Promesa</strong>
				<span class="room-progress" data-room-counter="promesa">0/0</span>
			  </div>
			</button>

			<button class="room-btn" data-room="libertad">
			  <span class="icon">‚á°</span>
			  <div class="room-meta">
				<small>3 ¬∑ √âxodo</small>
				<strong>Sala de la Libertad</strong>
				<span class="room-progress" data-room-counter="libertad">0/0</span>
			  </div>
			</button>

			<button class="room-btn" data-room="sabiduria">
			  <span class="icon">œÜ</span>
			  <div class="room-meta">
				<small>4 ¬∑ Sabidur√≠a</small>
				<strong>Sala de la Sabidur√≠a</strong>
				<span class="room-progress" data-room-counter="sabiduria">0/0</span>
			  </div>
			</button>

			<button class="room-btn" data-room="sacrificio">
			  <span class="icon">‚úù</span>
			  <div class="room-meta">
				<small>5 ¬∑ Pasi√≥n</small>
				<strong>Sala del Sacrificio</strong>
				<span class="room-progress" data-room-counter="sacrificio">0/0</span>
			  </div>
			</button>

			<button class="room-btn" data-room="vida">
			  <span class="icon">‚òº</span>
			  <div class="room-meta">
				<small>6 ¬∑ Resurrecci√≥n</small>
				<strong>Sala de la Vida Nueva</strong>
				<span class="room-progress" data-room-counter="vida">0/0</span>
			  </div>
			</button>
        </div>
      </div>

      <div class="sidebar-footer">
		  <div id="globalSolvedSummary" class="global-solved">
			0 acertijos resueltos en total
		  </div>
      </div>
    </aside>

	<main class="main">
  <!-- Pantalla de inicio -->
		<section id="homeSection" class="home">
		  <h1 class="home-title">ARCHIVUM</h1>
		  <p class="home-subtitle">Juego h√≠brido tablero + web, estilo Kahoot, con est√©tica b√≠blica y misteriosa.</p>

		  <h2 class="home-heading">Historia del Archivum</h2>
		  <p class="home-text">
			Se cuenta que en un antiguo monasterio exist√≠a un c√≥dice llamado <em>Archivum</em>,
			una recopilaci√≥n de relatos b√≠blicos, s√≠mbolos y enigmas que ayudaban a comprender
			la historia de la salvaci√≥n. Durante un incendio, muchas p√°ginas se perdieron o
			quedaron ilegibles.
		  </p>
		  <p class="home-text">
			Lo que ves ahora es el intento de reconstruir ese archivo. Cada sala corresponde
			a una etapa de la historia b√≠blica. Para recuperar los fragmentos perdidos tendr√°s
			que resolver acertijos de l√≥gica, matem√°ticas, filosof√≠a y escritura. Algunas
			pruebas te pedir√°n abrir la Biblia f√≠sica; otras jugar√°n con patrones, n√∫meros
			o s√≠mbolos.
		  </p>

		  <h2 class="home-heading">¬øC√≥mo se juega?</h2>
		  <ul class="home-list">
			<li><strong>Host (pantalla grande)</strong>: pulsa <em>Empezar partida</em>, elige n¬∫ de jugadores y acertijos por sala. Se mostrar√° un <strong>c√≥digo</strong> y un <strong>QR</strong> para unirse.</li>
			<li><strong>Jugadores (m√≥vil)</strong>: entrad con el QR/c√≥digo, escribid vuestro nombre y recibid un <strong>mandamiento</strong> y un <strong>n√∫mero secreto</strong> de orden.</li>
			<li>El host inicia la <strong>elecci√≥n de pecados</strong>. Cuando diga ‚ÄúN√öMERO X, elige‚Äù, solo ese jugador podr√° elegir su pecado en el m√≥vil y marcar ‚Äúlisto‚Äù.</li>
			<li>En campa√±a, el tablero f√≠sico marca la sala/c√≥digo (ej. <strong>OR-03</strong>). El host abre ese acertijo en la web y controla el avance.</li>
			<li>Cada acertijo tiene <strong>180s</strong> y <strong>2 intentos</strong>. La <strong>Pista 1</strong> es gratis; la <strong>Pista 2</strong> cuesta el <strong>s√≠mbolo</strong> del turno.</li>
			<li>En tu turno (m√≥vil) tienes <strong>1 s√≠mbolo</strong> y eliges <strong>solo una</strong>: desbloquear Pista 2, activar tu <strong>Mandamiento</strong> o activar tu <strong>Pecado</strong>.</li>
			<li>La <strong>Respuesta final</strong> la introduce y verifica <strong>solo el host</strong>. Si fall√°is, se consumen intentos y puede haber penalizaci√≥n de tiempo seg√∫n el modo.</li>
		  </ul>

			<div class="home-buttons">
			  <button id="startBtn" class="action primary">
				Empezar partida
			  </button>
			  <button id="exploreBtn" class="action secondary">
				Explorar salas
			  </button>
			  <button id="rulesBtn" class="action secondary">
				Ver reglas completas
			  </button>
			</div>
		</section>

		<section id="campaignSetupSection" class="campaign-setup" style="display:none;">
		  <h2 class="home-heading">Modo campa√±a</h2>
		  <p class="home-text">
			Configura la partida: n√∫mero de jugadores, dificultad y cu√°ntos acertijos
			quer√©is resolver en cada sala antes de avanzar en el tablero.
		  </p>

		  <div class="campaign-form">
			<label>
			  N√∫mero de jugadores
			  <input id="playersCountInput" type="number" min="1" max="7" value="3">
			</label>

			<label>
			  Acertijos por sala para avanzar
			  <input id="puzzlesPerRoomInput" type="number" min="1" max="10" value="3">
			</label>

			<label>
			  Tiempo l√≠mite por acertijo (segundos)
			  <input id="timeLimitSecInput" type="number" min="30" max="900" value="180">
			</label>

			<label>
			  Dificultad de los acertijos
				  <select id="puzzleDifficultyInput">
				    <option value="auto" selected>Mixta (todas)</option>
				    <option value="easy">F√°cil (F√°cil y F√°cil‚Äìmedia)</option>
				    <option value="normal">Media</option>
				    <option value="hard">Dif√≠cil (Media‚Äìdif√≠cil)</option>
				  </select>
				  <small style="display:block; opacity:.75; margin-top:6px;">Filtra qu√© c√≥digos de acertijo son v√°lidos en esta campa√±a.</small>
			</label>


			<p class="home-text" style="margin-top:8px;">
			  Los nombres se introducen desde el m√≥vil al unirse a la partida.
			</p>
			<input id="playersNamesInput" type="hidden" value="">
<p class="home-text" style="margin-top:8px;">
			  Al iniciar la campa√±a, la app repartir√° al azar los <strong>Mandamientos</strong>
			  (ventajas) y los <strong>Pecados capitales</strong> (restricciones) entre los jugadores.
			</p>

			<div class="home-buttons">
			  <button id="startCampaignBtn" class="action primary">
				Iniciar campa√±a
			  </button>
			  <button id="campaignBackBtn" class="action secondary">
				Volver al inicio
			  </button>
			</div>
		  </div>
		</section>

	<!-- REGLAS COMPLETAS -->
	
	<!-- REGLAS COMPLETAS (modo actual) -->
	<section id="rulesSection" class="rules" style="display:none;">
	  <h2 class="rules-title">REGLAS DE ARCHIVUM ‚Äî MODO KAHOOT (HOST + M√ìVILES)</h2>

	  <h3 class="rules-heading">1. Preparaci√≥n</h3>
	  <ul class="rules-list">
		<li><strong>Host (pantalla grande)</strong>: pulsa <em>Empezar partida</em>, configura jugadores y acertijos por sala.</li>
		<li>La web mostrar√° un <strong>c√≥digo</strong> y un <strong>QR</strong> para que los jugadores se unan desde el m√≥vil.</li>
		<li><strong>Jugadores (m√≥vil)</strong>: abren el enlace, escriben su nombre y quedan conectados.</li>
	  </ul>

	  <h3 class="rules-heading">2. Identidades secretas</h3>
	  <p class="rules-text">
		Al unirse, cada jugador recibe un <strong>Mandamiento</strong> (ventaja) y un <strong>n√∫mero secreto</strong> de orden.
		Ese n√∫mero solo sirve para la fase de elecci√≥n de pecados: el host dir√° ‚ÄúN√öMERO X, elige ahora‚Äù y solo ese jugador podr√° elegir.
	  </p>
	  <ul class="rules-list">
		<li><strong>Mandamiento</strong>: bendici√≥n + (a veces) voto/milagro.</li>
		<li><strong>Pecado capital</strong>: ventaja + coste + tentaci√≥n (ataque).</li>
		<li>Los roles son <strong>privados</strong>: el host no ve mandamientos ni pecados.</li>
	  </ul>
	  <h3 class="rules-heading">3. Mandamientos y pecados ‚Äî pasivas y activas</h3>
	  <p class="rules-text">
		<strong>Importante:</strong> tu rol es secreto (solo t√∫ lo ves en tu m√≥vil). Las <strong>pasivas</strong> se aplican autom√°ticamente
		(seg√∫n la descripci√≥n) y la <strong>activa</strong> se dispara desde el m√≥vil gastando el <strong>s√≠mbolo</strong> del turno.
	  </p>

	  <h4 class="rules-heading" style="font-size:1.1rem; margin-top:14px;">Mandamientos (Bendici√≥n + Voto + Milagro)</h4>
	  <div style="display:flex; flex-direction:column; gap:10px;">

        <details class="rules-detail">
          <summary><strong>Mandamiento I</strong> ‚Äî No tendr√°s otros dioses</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Al abrir Pista 1, ganas +10s (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> No puedes desbloquear Pista 2 hasta que el temporizador baje de 120s.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> +1 intento extra en tu turno (m√°x 3) (1 vez por acertijo).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento II</strong> ‚Äî No tomar√°s el Nombre en vano</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Tu primer fallo verificado del turno no penaliza -30s (solo -1 intento) (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> No puedes verificar con menos de 20s restantes.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> Congela el tiempo 15s antes de verificar (1 vez por partida).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento III</strong> ‚Äî Santificar√°s el descanso</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Si terminas tu turno con &gt;60s, guardas +10s para tu siguiente turno (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> Si desbloqueas Pista 2, tu siguiente turno empieza con -15s.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> ‚ÄúReintento‚Äù: si fallas una verificaci√≥n, recuperas +1 intento (una vez) (1 vez por acertijo).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento IV</strong> ‚Äî Honrar√°s a tu padre y madre</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> 1 vez por acertijo puedes pedir ‚ÄúPista 1 mejorada‚Äù (un matiz extra) sin coste.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> No puedes usar Milagro en un turno donde ya hayas desbloqueado Pista 2.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> Revela una ‚ÄúPalabra clave‚Äù del acertijo (1 vez por acertijo).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento V</strong> ‚Äî No matar√°s</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Tu primer fallo del turno no aplica -30s (solo -1 intento) (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> Si te queda 1 intento, no puedes gastar el s√≠mbolo en poderes: solo Pista 2 (o nada).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> ‚ÄúClemencia‚Äù: cancela una penalizaci√≥n personal activa este turno (1 vez por acertijo).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento VI</strong> ‚Äî No cometer√°s adulterio</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Si resuelves sin desbloquear Pista 2, tu siguiente turno gana +1 intento (m√°x 3) (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> Si desbloqueas Pista 2, debes verificar antes de que queden 60s o pierdes el turno.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> Si tu reloj baja de 60s, lo sube a 90s (1 vez por acertijo).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento VII</strong> ‚Äî No robar√°s</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Si fallas una verificaci√≥n, recuperas +10s (solo la primera vez por turno) (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> No puedes desbloquear Pista 2 dos turnos seguidos.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> ‚ÄúRestituir‚Äù: recupera +1 intento perdido del turno (m√°x hasta 2) (1 vez por acertijo).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento VIII</strong> ‚Äî No dar√°s falso testimonio</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Al escribir una respuesta, el host muestra ‚Äú‚úî formato v√°lido‚Äù (sin revelar si es correcta).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> Solo puedes verificar 1 vez por turno.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> ‚ÄúVeredicto‚Äù: el host te da ‚Äúm√°s cerca/m√°s lejos‚Äù comparado con tu √∫ltima respuesta (1 vez por partida).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento IX</strong> ‚Äî No codiciar√°s bienes ajenos</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Si el jugador anterior gast√≥ el s√≠mbolo en un poder, t√∫ ganas +10s al inicio de tu turno (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> No puedes usar Milagro hasta haber hecho al menos 1 verificaci√≥n (o consumido 1 intento) en tu turno.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> Desbloquea Pista 2 en tu turno. (Se considera el gasto del s√≠mbolo del turno.) (1 vez por acertijo).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Mandamiento X</strong> ‚Äî No codiciar√°s la pareja del pr√≥jimo</summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Bendici√≥n:</strong> Si la respuesta es texto, se aceptan variantes ortogr√°ficas (tildes, may√∫sculas, espacios y plural) salvo que uses Pista 2.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Voto:</strong> Si desbloqueas Pista 2, tu respuesta debe ser exacta (can√≥nica) (sin variantes).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Milagro (gasta s√≠mbolo):</strong> ‚ÄúInspiraci√≥n‚Äù: a√±ade +30s al reloj del turno (1 vez por acertijo).</p>
          </div>
        </details>
	  </div>

	  <h4 class="rules-heading" style="font-size:1.1rem; margin-top:18px;">Pecados capitales (Ventaja + Coste + Tentaci√≥n)</h4>
	  <div style="display:flex; flex-direction:column; gap:10px;">

        <details class="rules-detail">
          <summary><strong>Soberbia</strong></summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Ventaja:</strong> +10s al inicio de tu turno (1 vez por acertijo).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Coste:</strong> Si fallas una verificaci√≥n, pierdes -10s extra.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Tentaci√≥n (gasta s√≠mbolo):</strong> El objetivo empieza su pr√≥ximo turno con -30s.</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Avaricia</strong></summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Ventaja:</strong> Si resuelves sin desbloquear Pista 2, guardas 1 ‚ÄúMoneda‚Äù (m√°x 1) ‚Üí en otro turno te da +1 intento.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Coste:</strong> Si desbloqueas Pista 2, pierdes -15s.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Tentaci√≥n (gasta s√≠mbolo):</strong> El objetivo no puede usar bol√≠grafo/notas en su pr√≥ximo turno (solo mente/voz).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Lujuria</strong></summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Ventaja:</strong> 1 vez por acertijo puedes resetear tu reloj a 120s si est√° por debajo.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Coste:</strong> Si fallas una vez, el resto del turno no puedes pedir pistas.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Tentaci√≥n (gasta s√≠mbolo):</strong> El objetivo no puede usar Pista 1 durante sus primeros 60s.</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Envidia</strong></summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Ventaja:</strong> Si el jugador anterior acert√≥, t√∫ empiezas con +1 intento (m√°x 3).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Coste:</strong> Si t√∫ aciertas, tu siguiente turno empieza con -10s.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Tentaci√≥n (gasta s√≠mbolo):</strong> El objetivo no puede gastar s√≠mbolo en Pista 2 ese turno (Pista 2 bloqueada).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Gula</strong></summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Ventaja:</strong> Puedes ver Pista 1 sin consumir nada aunque el host a√∫n no la muestre (privada) 1 vez por acertijo.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Coste:</strong> Cada pista que uses te cuesta -10s.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Tentaci√≥n (gasta s√≠mbolo):</strong> El objetivo pierde -15s y su penalizaci√≥n por fallo es -45s (en vez de -30s) ese turno.</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Ira</strong></summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Ventaja:</strong> Cuando fallas, recuperas +1 intento (solo 1 vez por partida).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Coste:</strong> Si te queda 1 intento, est√°s obligado a verificar antes de que queden 30s.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Tentaci√≥n (gasta s√≠mbolo):</strong> Si el objetivo falla una verificaci√≥n, pierde -1 intento extra (castigo doble).</p>
          </div>
        </details>

        <details class="rules-detail">
          <summary><strong>Pereza</strong></summary>
          <div class="rules-text" style="margin-top:10px;">
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Ventaja:</strong> Si no usas pistas, terminas el turno con +15s guardados para el siguiente (m√°x +15).</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Pasiva ‚Äî Coste:</strong> Empiezas siempre con -10s.</p>
            <p class="rules-text" style="margin:6px 0;"><strong>Activa ‚Äî Tentaci√≥n (gasta s√≠mbolo):</strong> El objetivo no puede verificar hasta que el reloj baje de 120s (primeros 60s bloqueado).</p>
          </div>
        </details>
	  </div>


	  <h3 class="rules-heading">4. Campa√±a y tablero f√≠sico</h3>
	  <p class="rules-text">
		El tablero f√≠sico marca el viaje por las 6 salas: Origen, Promesa, Libertad, Sabidur√≠a, Sacrificio y Vida Nueva.
		Cuando el tablero os d√© un c√≥digo (ej. <strong>OR-03</strong>), el host lo introduce y abre ese acertijo en la web.
	  </p>

	  <h3 class="rules-heading">4. C√≥mo funciona un acertijo</h3>
	  <ul class="rules-list">
		<li><strong>Tiempo</strong>: 180 segundos.</li>
		<li><strong>Intentos</strong>: 2.</li>
		<li><strong>Pista 1</strong> es gratis.</li>
		<li><strong>Pista 2</strong> solo se desbloquea gastando el <strong>s√≠mbolo</strong> del turno del jugador activo.</li>
		<li>La <strong>Respuesta final</strong> se escribe y se verifica <strong>solo en el host</strong>.</li>
	  </ul>

	  <h3 class="rules-heading">6. S√≠mbolo de turno y acciones del m√≥vil</h3>
	  <p class="rules-text">
		En cada turno, el jugador activo tiene <strong>1 s√≠mbolo</strong> y debe escoger <strong>solo una</strong> acci√≥n:
	  </p>
	  <ul class="rules-list">
		<li>Gastar s√≠mbolo para <strong>desbloquear Pista 2</strong>.</li>
		<li>Gastar s√≠mbolo para activar el <strong>Milagro</strong> de su Mandamiento.</li>
		<li>Gastar s√≠mbolo para activar la <strong>Tentaci√≥n</strong> de su Pecado (elige un objetivo).</li>
	  </ul>
	  <p class="rules-text">
		Una vez gastado el s√≠mbolo, los botones del m√≥vil quedan bloqueados hasta el siguiente turno.
	  </p>

	  <h3 class="rules-heading">7. Tentaciones (pecados) y secreto del atacante</h3>
	  <p class="rules-text">
		Cuando alguien te aplica un pecado, el host solo ver√° el mensaje de <strong>‚ÄúTentaci√≥n recibida: [Pecado]‚Äù</strong>,
		<strong>sin indicar qui√©n lo ha lanzado</strong>. El efecto se aplica en el turno del objetivo (seg√∫n la tentaci√≥n concreta).
	  </p>

	  <h3 class="rules-heading">8. Errores, fallos y salto de acertijo</h3>
	  <ul class="rules-list">
		<li>Si la respuesta es incorrecta: se consume un intento y puede aplicarse penalizaci√≥n de tiempo seg√∫n el modo.</li>
		<li>Con 0 intentos (o por decisi√≥n del host), se puede marcar <strong>fallo final</strong> y pasar al siguiente turno.</li>
		<li>Al volver al tablero no hay acertijo activo: nadie puede usar acciones hasta que el host abra el siguiente.</li>
	  </ul>

	  <h3 class="rules-heading">8. Explorar salas (modo libre)</h3>
	  <p class="rules-text">
		En <strong>Explorar salas</strong> pod√©is navegar por los acertijos sin campa√±a ni turnos. √ötil para pruebas, preparaci√≥n o sesiones cortas.
	  </p>

	  <h3 class="rules-heading">9. Fin de la partida</h3>
	  <p class="rules-text">
		La campa√±a termina cuando complet√°is el objetivo acordado (por ejemplo, <em>N</em> acertijos por sala o alcanzar la Sala de la Vida Nueva).
	  </p>

	  <div class="home-buttons" style="margin-top:14px;">
		<button id="rulesBackBtn" class="action secondary">Volver al inicio</button>
	  </div>
	</section>


		

	<!-- NUEVA PANTALLA: unirse con m√≥viles (estilo Kahoot) -->
	<section id="campaignJoinSection" style="display:none;">
	  <h2 class="rules-heading">Unirse a la partida</h2>
	  <p class="rules-text">
		Cada jugador abre este enlace en su m√≥vil (o escanea el QR) para recibir su mandamiento y su n√∫mero secreto.
	  </p>

	  <div class="roles-grid" style="grid-template-columns: 1fr; max-width: 720px;">
		<div class="player-role-card">
		  <div class="player-role-header">C√≥digo de partida</div>
		  <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
			<div style="font-size:1.8rem; letter-spacing:0.2em; font-weight:700; color:var(--accent);"
				 id="joinCodeText">----</div>
			<button class="action secondary" id="copyJoinLinkBtn" type="button">Copiar enlace</button>
		  </div>
		  <p class="rules-text" style="margin-top:10px; opacity:0.9;">
			Enlace para m√≥viles: <span id="joinLinkText" style="word-break:break-all;"></span>
		  </p>
		  <div id="qrWrap" style="margin-top:12px; display:flex; justify-content:center;"></div>

		  <hr style="border:0; border-top:1px solid rgba(255,255,255,0.12); margin:14px 0;">

		  <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;">
			<div>
			  <div class="role-card-label">Jugadores conectados</div>
			  <div style="font-size:1.1rem; margin-top:4px;"><span id="joinedCount">0</span>/<span id="maxCount">0</span></div>
			</div>
			<button class="action primary" id="startSinRitualBtn" type="button" disabled>Comenzar elecci√≥n de pecados</button>
		  </div>

		  <p id="joinStatusText" class="rules-text" style="margin-top:10px; opacity:0.85;"></p>
		</div>
	  </div>

	  <div class="roles-actions">
		<button id="joinCancelBtn" class="action secondary" type="button">Cancelar</button>
	  </div>
	</section>


	<!-- NUEVA PANTALLA: m√≥vil del jugador -->
	<section id="playerSection" style="display:none;">
	  <h2 class="rules-heading">ARCHIVUM ‚Äî Jugador</h2>

	  <div class="roles-grid" style="grid-template-columns: 1fr; max-width: 720px;">
		<div class="player-role-card" id="playerJoinCard">
		  <div class="player-role-header">Unirse</div>
		  <p class="rules-text">Introduce tu nombre para unirte a la partida.</p>
		  <label class="rules-text" style="display:block; margin-top:8px;">
			Nombre
			<input id="playerNameInput" type="text" placeholder="Tu nombre" style="width:100%; margin-top:6px;">
		  </label>
		  <button class="action primary" id="playerJoinBtn" type="button" style="margin-top:12px;">Unirme</button>
		  <p id="playerJoinError" class="rules-text" style="margin-top:10px; color:#ffb3b3; display:none;"></p>
		</div>

		<div class="player-role-card" id="playerInfoCard" style="display:none;">
		  <div class="player-role-header">Tu identidad</div>
		  <p class="rules-text" style="margin-bottom:10px;">
			Tu n√∫mero secreto para elegir pecado es:
			<span id="playerPickNumber" style="font-weight:800; color:var(--accent); font-size:1.2rem;"></span>
		  </p>

		  <article class="role-card role-card--commandment" style="margin-bottom:12px;">
			<header>
			  <div class="role-card-label">Mandamiento</div>
			  <div class="role-card-name" id="playerCommandmentName">‚Äî</div>
			</header>
			<div class="role-card-body">
			  <img id="playerCommandmentImg" src="" alt="" style="display:none;">
			  <p class="role-card-desc" id="playerCommandmentDesc">‚Äî</p>
			</div>
		  </article>

		  <article class="role-card role-card--sin">
			<header>
			  <div class="role-card-label">Pecado capital</div>
			  <div class="role-card-name" id="playerSinName">A√∫n sin elegir</div>
			</header>
			<div id="playerSinBody" class="role-card-body" style="display:none;">
			  <img id="playerSinImg" src="" alt="">
			  <p class="role-card-desc" id="playerSinDesc"></p>
			</div>
			<p class="role-card-desc" id="playerSinHint">
			  Espera tu turno. Cuando el host diga ‚ÄúN√öMERO X, elegid pecado‚Äù, aqu√≠ se activar√° la selecci√≥n.
			</p>
			<button class="action primary" id="playerOpenSinPickerBtn" type="button" style="display:none; margin-top:10px;">
			  Elegir mi pecado ahora
			</button>
		  </article>

		  
          <div class="player-role-card" id="playerTurnCard" style="margin-top:14px; display:none;">
            <div class="player-role-header">Acci√≥n de turno</div>
            <p id="playerTurnStatus" class="rules-text" style="margin:10px 0; opacity:0.9;"></p>
            <div class="controls" style="display:flex; flex-direction:column; gap:10px;">
              <button class="action" id="playerUnlockHint2Btn" type="button">Gastar s√≠mbolo: desbloquear Pista 2</button>
              <button class="action primary" id="playerUseCommandmentPowerBtn" type="button">Gastar s√≠mbolo: activar mi Mandamiento</button>
              <button class="action secondary" id="playerUseSinPowerBtn" type="button">Gastar s√≠mbolo: activar mi Pecado</button>
            </div>
          </div>

<p id="playerPhaseText" class="rules-text" style="margin-top:12px; opacity:0.9;"></p>
		</div>
	  </div>
	</section>


	<!-- MODAL: elegir objetivo para Pecado (m√≥vil) -->
	<div id="targetPickerOverlay" class="modal-overlay" style="display:none;" aria-hidden="true">
	  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="targetPickerTitle">
		<div class="modal-title" id="targetPickerTitle">Elige objetivo</div>
		<p class="modal-subtitle" id="targetPickerSubtitle">Selecciona a qui√©n aplicar la tentaci√≥n.</p>
		<div id="targetPickerList" class="modal-list"></div>
		<div class="modal-actions">
		  <button id="targetPickerCancelBtn" class="action secondary" type="button">Cancelar</button>
		</div>
	  </div>
	</div>

	<!-- NUEVA PANTALLA: asignaci√≥n de mandamientos y pecados -->
	<section id="campaignRolesSection" style="display:none;">
	  <h2 class="rules-heading">Campa√±a ‚Äì Mandamientos y pecados</h2>
	  <p class="rules-text">
		Cada jugador recibe un mandamiento como bendici√≥n y elige un pecado capital
		como debilidad. L√©elos con calma: lo que te toque afectar√° a c√≥mo juegas
		durante toda la campa√±a.
	  </p>

	  <div id="rolesPlayersContainer" class="roles-grid">
		<!-- aqu√≠ se generar√°n las tarjetas de cada jugador (mandamiento + pecados) -->
	  </div>

	  <div class="roles-actions">
		<button id="rolesToBoardBtn" class="action primary" disabled>
		  Continuar al tablero
		</button>
		<button id="rolesCancelBtn" class="action secondary">
		  Cancelar campa√±a
		</button>
	  </div>
	</section>


	<!-- PANTALLA DEL TABLERO (la que ya tienes ahora) -->
	<section id="campaignBoardSection" style="display:none;">
	  <div class="board-layout">
		<div class="board-main">
		  <img src="tablero-archivum.png"
			   alt="Tablero de ARCHIVUM"
			   class="board-image">
		  <!-- Aqu√≠ podr√≠as dibujar posiciones de cada jugador m√°s adelante -->
		</div>

		<aside class="board-sidebar">
		  <h2 class="home-heading">Campa√±a en curso</h2>
		  <div id="playersSummary" class="players-summary">
			<!-- Se rellena por JS con jugadores, mandamientos y pecados -->
		  </div>

		<div class="board-controls" id="boardControls">
		  <h3>C√≥digo del acertijo (ej: OR-03)</h3>
		  <input type="text" id="codeInput" placeholder="Escribe el c√≥digo que indica el tablero...">
		  <button id="goToCodeBtn">Ir al acertijo</button>
		</div>

		  <button id="endCampaignBtn" class="action secondary">
			Terminar campa√±a y volver al inicio
		  </button>
		</aside>
	  </div>
	</section>

	<!-- Secci√≥n de sala (imagen + acertijos) -->
	<div id="roomSection" style="display:none;">
		  <!-- Bot√≥n de m√∫sica espec√≠fico de la sala -->
		  <div class="room-music-toggle" style="display:none;">
			<button id="roomMusicToggleBtn" class="action secondary small" type="button">
			  üîä M√∫sica de la sala: ON
			</button>
		  </div>
		<header class="room-header">
		  <div class="room-header-left">
			<h2 id="roomTitle">Sala del Origen</h2>
			<p id="roomSubtitle">
			  Creaci√≥n, primeros relatos y el misterio del inicio.
			</p>
		  </div>

		  <div class="room-header-right">
			<div class="puzzle-jump">
			  <input
				id="puzzleCodeInput"
				type="text"
				placeholder="OR-01"
				autocomplete="off"
			  />
			  <button id="puzzleCodeBtn" class="action small">
				Ir
			  </button>
			</div>

			<div class="progress">
			  <span id="puzzleCounter">Acertijo 1 de 1</span>
				<span id="roomSolvedSummary" class="room-solved-summary">
				  Resueltos en esta sala: 0 de 0
				</span>			  
			  <div class="progress-bar">
				<div class="progress-fill" id="progressFill"></div>
			  </div>
			</div>

			<div id="puzzleCodeMessage" class="puzzle-code-message"></div>
		  </div>
		</header>

		<section class="image-section">
		  <div class="image-frame">
			<!-- Cambia la ruta de esta imagen por tu tablero de la sala -->
			<img id="roomImage"
				 src="sala-origen.png"
				 alt="Ilustraci√≥n de la sala actual" />
		  </div>
		  <p class="tagline" id="roomTagline">
			‚ÄúEn el principio‚Ä¶‚Äù ‚Äì G√©nesis, del caos al orden.
		  </p>
		</section>


      <section class="puzzle-card">
        <div class="puzzle-meta">
          <div class="puzzle-meta-left">
            <div class="pill">
              <span class="dot"></span>
              <span id="puzzleId">OR-01</span>
              <span>¬∑</span>
              <span id="puzzleDifficulty">Media</span>
            </div>
            <h3 id="puzzleTitle">T√≠tulo del acertijo</h3>
            <span id="puzzleState" class="puzzle-state">Sin resolver</span>
          </div>
          <div id="puzzleTags" class="pill"></div>
        </div>

        <p class="puzzle-body" id="puzzleBody">
          Carga inicial‚Ä¶
        </p>

        <div id="bibleBadge" class="badge-bible" style="display:none;">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor"
              d="M6 3h11a2 2 0 0 1 2 2v14.5a.5.5 0 0 1-.8.4L16 18.5l-2.2 1.4a.5.5 0 0 1-.8-.4V5H6a1 1 0 0 0-1 1v11H4V6a2 2 0 0 1 2-2zm8 2v10.7l1.7-1.1a.5.5 0 0 1 .6 0l1.7 1.1V5h-4z" />
          </svg>
          <span>Este acertijo puede requerir una Biblia f√≠sica.</span>
        </div>

        <div class="controls">
          <button id="hint1Btn" class="action">Pista 1</button>
          <button id="hint2Btn" class="action">Pista 2</button>
          <button id="solutionBtn" class="action">Ver soluci√≥n</button>
          <button id="toggleSolvedBtn" class="action secondary">Marcar como resuelto</button>
          <button id="prevBtn" class="action secondary">Anterior acertijo</button>
          <button id="nextBtn" class="action primary">Siguiente acertijo</button>
          <button id="backToBoardBtn" class="action secondary">Volver al tablero</button>
        </div>
		
		<div class="puzzle-meta">
		  <div class="timer-wrap">
			<span class="timer-label">Tiempo</span>
			<span id="campaignTimer" class="timer">03:00</span>
		  </div>

		  
          <div class="attempts-wrap">
            <span class="timer-label">Intentos</span>
            <span id="campaignAttempts" class="timer">2</span>
          </div>
          <div id="campaignStatus" class="rules-text" style="margin-top:8px; opacity:0.85;"></div>

          <button id="failAttemptBtn" class="btn ghost">Fallo (-1 intento)</button>
<button id="skipPuzzleBtn" class="btn ghost">Saltar acertijo</button>

          <div id="answerBar" class="answer-bar">
            <input id="answerInput" type="text" inputmode="text" autocomplete="off" spellcheck="false"
                   placeholder="Respuesta final (solo host)‚Ä¶" />
            <button id="verifyAnswerBtn" class="action primary">Verificar</button>
            <button id="manualCorrectBtn" class="action secondary" title="Si no hay verificaci√≥n autom√°tica, marca como resuelto manualmente.">Marcar correcto</button>
            <div id="answerFeedback" class="answer-feedback" aria-live="polite"></div>
          </div>

		</div>

        <div id="hint1" class="reveal"></div>
        <div id="hint2" class="reveal"></div>
        <div id="solution" class="reveal"></div>
    </main>
	<audio id="roomAudio" loop style="display:none;" preload="auto" playsinline></audio>
	<audio id="bgAudio" src="background-theme.mp3" loop style="display:none;" preload="auto" playsinline></audio>
  </div>

	<!-- Overlay de selecci√≥n de pecado -->
	<div id="sinOverlay" class="sin-overlay sin-overlay--hidden">
	  <div class="sin-overlay-inner">
		<button id="sinOverlayClose" class="sin-overlay-close" aria-label="Cerrar selecci√≥n de pecado">
		  √ó
		</button>
		<h2 id="sinOverlayTitle" class="sin-overlay-title">Elige un pecado</h2>
		<p class="sin-overlay-subtitle">
		  Cada pecado tiene una debilidad distinta. Elige con sabidur√≠a.
		</p>

		<div id="sinCarousel" class="sin-carousel">
		  <!-- Aqu√≠ se inyectan las cartas de pecados por JS -->
		</div>
	  </div>
	</div>


<!-- Multiplayer libs (Firebase + QRCode) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>

<script src="puzzles_roles_final.js"></script>
<script>

// ---------------------------
// C√≥dice: mostrar recompensa por sala (HOST)
// ---------------------------
const CODEX_REWARD_IMAGES = {
  origen: "origen_codice.png",
  promesa: "promesa_codice.png",
  libertad: "libertad_codice.png",
  sabiduria: "sabiduria_codice.png",
  sacrificio: "sacrificio_codice.png",
  vida: "vida_codice.png",
  vidanueva: "vida_codice.png",
  "vida-nueva": "vida_codice.png",
  "vida_nueva": "vida_codice.png"
};

function normalizeRoomKeyForCodex(roomKey){
  return String(roomKey || "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g,"")
    .replace(/[√°√†√§]/g,"a")
    .replace(/[√©√®√´]/g,"e")
    .replace(/[√≠√¨√Ø]/g,"i")
    .replace(/[√≥√≤√∂]/g,"o")
    .replace(/[√∫√π√º]/g,"u")
    .replace(/[^a-z0-9_-]/g,"");
}

function showCodexReward(roomKey){
  try{
    if (appMode !== "host") return;

    const overlay = document.getElementById("codexRewardOverlay");
    const img = document.getElementById("codexRewardImg");
    const hint = document.getElementById("codexRewardHint");
    const btn = document.getElementById("codexRewardBtn");
    if (!overlay || !img || !btn || !hint) return;

    const k = normalizeRoomKeyForCodex(roomKey);
    const src = CODEX_REWARD_IMAGES[k];

    // Estado por defecto
    hint.textContent = "Fragmento del C√≥dice obtenido";
    img.style.display = "";
    img.onerror = null;

    // Si no hay imagen o falla la carga, mostramos placeholder (pero el fundido ocurre igual)
    const setMissing = () => {
      img.style.display = "none";
      hint.textContent = `Fragmento desbloqueado (${roomKey}). Imagen no encontrada.`;
    };

    if (src) {
      img.src = src;
      img.onerror = setMissing;
    } else {
      img.src = "";
      setMissing();
    }

    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden","false");

    const close = () => {
      overlay.classList.remove("show");
      overlay.setAttribute("aria-hidden","true");
      overlay.style.display = "none";
      // reflow hack to allow next show to animate
      void overlay.offsetHeight;
      overlay.style.display = "";
      document.removeEventListener("keydown", onKey);
      overlay.removeEventListener("click", onBg);
      btn.removeEventListener("click", close);
    };

    const onKey = (e) => { if (e.key === "Escape" || e.key === "Enter" || e.key === " ") close(); };
    const onBg = (e) => { if (e.target === overlay) close(); };

    document.addEventListener("keydown", onKey);
    overlay.addEventListener("click", onBg);
    btn.addEventListener("click", close);

    // Enfocar el bot√≥n para evitar warnings de aria-hidden/focus al cambiar de vista
    setTimeout(() => { try { btn.focus({ preventScroll:true }); } catch(_){} }, 30);

  } catch (e){
    console.warn("showCodexReward error", e);
  }
}


</script>


  <!-- Ritual overlay (suave, estilo ARCHIVUM) -->
  <div id="ritualOverlay" aria-hidden="true">
    <div id="ritualCard" class="fade-pop">
      <div id="ritualTitle">RITUAL</div>
      <p id="ritualText">Cerrad los ojos‚Ä¶</p>
    </div>
  </div>

<script>
/* ===== Codex Reward Overlay (global) ===== */
(function(){
  const CODex_IMAGE_BY_ROOM = {
    "origen": "origen_codice.png",
    "promesa": "promesa_codice.png",
    "libertad": "libertad_codice.png",
    "sabiduria": "sabiduria_codice.png",
    "sacrificio": "sacrificio_codice.png",
    "vidanueva": "vida_codice.png",
    "vida-nueva": "vida_codice.png",
    "vida_nueva": "vida_codice.png",
    "vida": "vida_codice.png"
  };

  function normalizeRoomKey(roomKey){
    return String(roomKey || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g,"")
      .replace(/[√°√†√§]/g,"a")
      .replace(/[√©√®√´]/g,"e")
      .replace(/[√≠√¨√Ø]/g,"i")
      .replace(/[√≥√≤√∂]/g,"o")
      .replace(/[√∫√π√º]/g,"u")
      .replace(/[^a-z0-9_-]/g,"");
  }

  window.showCodexReward = function(roomKey){
    // Host only: if URL says mode=player, do nothing
    const params = new URLSearchParams(location.search);
    const mode = (params.get("mode") || "").toLowerCase();
    if (mode === "player") return;

    const overlay = document.getElementById("codexRewardOverlay");
    const img = document.getElementById("codexRewardImg");
    const hint = document.getElementById("codexRewardHint");
    const btn = document.getElementById("codexRewardBtn");
    if (!overlay || !img || !hint || !btn) return;

    const key = normalizeRoomKey(roomKey);
    const src = (typeof CODEX_REWARD_IMAGES !== "undefined" && CODEX_REWARD_IMAGES[key]) ? CODEX_REWARD_IMAGES[key] : null;

    // Always show overlay (even if image missing)
    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden","false");

    // Default text
    const pretty = (key || "desconocida").toUpperCase();
    hint.textContent = `Fragmento del C√≥dice obtenido: ${pretty}`;

    // Close handler
    const close = () => {
      overlay.classList.remove("show");
      overlay.setAttribute("aria-hidden","true");
      btn.removeEventListener("click", close);
      overlay.removeEventListener("click", onBg);
      document.removeEventListener("keydown", onKey);
    };
    const onBg = (e) => { if (e.target === overlay) close(); };
    const onKey = (e) => { if (e.key === "Escape") close(); };

    btn.addEventListener("click", close);
    overlay.addEventListener("click", onBg);
    document.addEventListener("keydown", onKey);

    // Try load image if we have a src
    if (src){
      img.style.display = "block";
      img.src = src;
      img.onerror = () => {
        img.style.display = "none";
        hint.textContent = `Fragmento del C√≥dice obtenido: ${pretty} (imagen no encontrada)`;
      };
    } else {
      img.style.display = "none";
      hint.textContent = `Fragmento del C√≥dice obtenido: ${pretty} (imagen no encontrada)`;
    }

    // Focus button to avoid aria-hidden focus warning
    try{ btn.focus({preventScroll:true}); }catch(e){}
  };
})();
window.addEventListener("DOMContentLoaded", () => {


  const appRoot = document.getElementById("appRoot");
  const homeSection = document.getElementById("homeSection");
  
  const campaignSetupSection = document.getElementById("campaignSetupSection");
  const boardSection = document.getElementById("campaignBoardSection");
  const boardMain = document.querySelector(".board-main");
  const roomSection = document.getElementById("roomSection");
  const boardControls = document.getElementById("boardControls");

	// Overlay de pecados
	const sinOverlay = document.getElementById("sinOverlay");
	const sinOverlayTitle = document.getElementById("sinOverlayTitle");
	const sinOverlayClose = document.getElementById("sinOverlayClose");
	const sinCarousel = document.getElementById("sinCarousel");

	let sinSelectionPlayerId = null;
  
	const CAMPAIGN_PER_ROOM_TARGET = 3;

  const globalMusicToggleContainer = document.querySelector(".global-music-toggle");
  const roomMusicToggleContainer = document.querySelector(".room-music-toggle");
  const roomMusicToggleBtn = document.getElementById("roomMusicToggleBtn");
  const rulesSection = document.getElementById("rulesSection");
  const homeLogo = document.getElementById("homeLogo");
  const startBtn = document.getElementById("startBtn");
  const exploreBtn = document.getElementById("exploreBtn");
  const rulesBtn = document.getElementById("rulesBtn");
  const rulesBackBtn = document.getElementById("rulesBackBtn");
  const playersCountInput = document.getElementById("playersCountInput");
  const puzzlesPerRoomInput = document.getElementById("puzzlesPerRoomInput");
    const timeLimitSecInput = document.getElementById("timeLimitSecInput");
  const puzzleDifficultyInput = document.getElementById("puzzleDifficultyInput");
const playersNamesInput = document.getElementById("playersNamesInput");
  const startCampaignBtn = document.getElementById("startCampaignBtn");
  const campaignBackBtn = document.getElementById("campaignBackBtn");
  const playersSummaryEl = document.getElementById("playersSummary");
  const codeInput = document.getElementById("codeInput");
  const goToCodeBtn = document.getElementById("goToCodeBtn");
  const endCampaignBtn = document.getElementById("endCampaignBtn");
  const roomButtons = document.querySelectorAll(".room-btn");
  const roomTitleEl = document.getElementById("roomTitle");
  const roomSubtitleEl = document.getElementById("roomSubtitle");
  const roomTaglineEl = document.getElementById("roomTagline");
  const roomImageEl = document.getElementById("roomImage");
  const roomAudioEl = document.getElementById("roomAudio");
  const bgAudioEl = document.getElementById("bgAudio");
  const sidebar = document.querySelector(".sidebar");
  const puzzleCounterEl = document.getElementById("puzzleCounter");
  const progressFillEl = document.getElementById("progressFill");
  const roomSolvedSummaryEl = document.getElementById("roomSolvedSummary");
  const globalSolvedSummaryEl = document.getElementById("globalSolvedSummary");
  const puzzleCodeInput = document.getElementById("puzzleCodeInput");
  const puzzleCodeBtn = document.getElementById("puzzleCodeBtn");
  const puzzleCodeMessage = document.getElementById("puzzleCodeMessage");
  const puzzleCardEl = document.querySelector(".puzzle-card");
  const puzzleStateEl = document.getElementById("puzzleState");
  const puzzleIdEl = document.getElementById("puzzleId");
  const puzzleDifficultyEl = document.getElementById("puzzleDifficulty");
  const puzzleTitleEl = document.getElementById("puzzleTitle");
  const puzzleBodyEl = document.getElementById("puzzleBody");
  const puzzleTagsEl = document.getElementById("puzzleTags");
  const bibleBadgeEl = document.getElementById("bibleBadge");
  const hint1Btn = document.getElementById("hint1Btn");
  const hint2Btn = document.getElementById("hint2Btn");
  const solutionBtn = document.getElementById("solutionBtn");
  const toggleSolvedBtn = document.getElementById("toggleSolvedBtn");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const backToBoardBtn = document.getElementById("backToBoardBtn");
  const hint1El = document.getElementById("hint1");
  const hint2El = document.getElementById("hint2");
  const solutionEl = document.getElementById("solution");

	const rolesSection = document.getElementById("campaignRolesSection");
	const rolesPlayersContainer = document.getElementById("rolesPlayersContainer");
	const rolesToBoardBtn = document.getElementById("rolesToBoardBtn");
	const rolesCancelBtn = document.getElementById("rolesCancelBtn");


/* startCampaignBtn listener replaced by multiplayer host flow */

  if (campaignBackBtn) {
    campaignBackBtn.addEventListener("click", showHome);
  }

  if (goToCodeBtn && codeInput) {
    goToCodeBtn.addEventListener("click", () => {
      const result = findPuzzleByCode(codeInput.value);
      if (!result) {
        alert("No se ha encontrado ese c√≥digo.");
        return;
      }

      // ‚úÖ Dificultad: en campa√±a, bloquea c√≥digos fuera del filtro elegido
      const selDiff = getSelectedDifficulty();
      const puzzle = (rooms[result.roomKey] && rooms[result.roomKey].puzzles)
        ? rooms[result.roomKey].puzzles[result.index]
        : null;
      if (!puzzleMatchesDifficulty(puzzle, selDiff)) {
        const pDiff = (puzzle && puzzle.difficulty) ? puzzle.difficulty : "desconocida";
        alert(`‚õî Este c√≥digo es de dificultad ${pDiff} y la campa√±a est√° en ${difficultyLabel(selDiff)}. Elige otro c√≥digo.`);
        return;
      }

      if (campaignState) {
        campaignState.lastLoadedCode = result.code;        // ej: "OR-03"
        campaignState.lastLoadedRoomKey = result.roomKey;  // ej: "origen"
      }
      gameMode = "campaign-room";
      loadRoom(result.roomKey, result.index);
    });
  }
if (endCampaignBtn) {
    endCampaignBtn.addEventListener("click", () => {
      campaignState = null;
  if (appMode !== "player") {
    showHome();
  }
    });
  }

  if (puzzleCodeBtn && puzzleCodeInput) {
    function handleRoomCodeSearch() {
      const result = findPuzzleByCode(puzzleCodeInput.value);
      if (!result) {
        if (puzzleCodeMessage) {
          puzzleCodeMessage.textContent = "No se ha encontrado ese c√≥digo.";

        }
        return;
      }

      // ‚úÖ Dificultad: en campa√±a, bloquea c√≥digos fuera del filtro elegido
      if (gameMode === "campaign-room" || gameMode === "campaign-board") {
        const selDiff = getSelectedDifficulty();
        const puzzle = (rooms[result.roomKey] && rooms[result.roomKey].puzzles)
          ? rooms[result.roomKey].puzzles[result.index]
          : null;
        if (!puzzleMatchesDifficulty(puzzle, selDiff)) {
          const pDiff = (puzzle && puzzle.difficulty) ? puzzle.difficulty : "desconocida";
          if (puzzleCodeMessage) {
            puzzleCodeMessage.textContent = `‚õî Este c√≥digo es de dificultad ${pDiff} y la campa√±a est√° en ${difficultyLabel(selDiff)}.`;
          } else {
            alert(`‚õî Este c√≥digo es de dificultad ${pDiff} y la campa√±a est√° en ${difficultyLabel(selDiff)}.`);
          }
          return;
        }
      }

      // Campa√±a (host): publica acertijo activo para el turno
      if (gameMode === "campaign-room" && multiplayer.roomRef && appMode !== "player") {
        multiplayer.roomRef.update({
          currentPuzzleCode: result.code,
          currentRoomKey: result.roomKey,
          hint2Unlocked: false,
          turnTokenUsed: false
        }).catch(()=>{});
      }

      // Si el c√≥digo pertenece a la sala actual, cambiamos solo el acertijo (sin transici√≥n)
      if (result.roomKey === currentRoomKey) {
        currentPuzzleIndex = result.index;
        loadPuzzle();
        updateRoomSolvedSummary();
        updateSidebarRoomCounters();
        updateGlobalSolvedSummary();
      } else {
        // Cambio de sala: pasa por la transici√≥n (negro -> cambio -> vuelve)
        loadRoom(result.roomKey, result.index);
      }

      puzzleCodeInput.value = result.code;
      if (puzzleCodeMessage) puzzleCodeMessage.textContent = "";
    }

    puzzleCodeBtn.addEventListener("click", handleRoomCodeSearch);
    puzzleCodeInput.addEventListener("keydown", ev => {
      if (ev.key === "Enter") handleRoomCodeSearch();
    });
  }

  if (hint1Btn && hint1El) {
    hint1Btn.addEventListener("click", () => {
      if (hint1Btn.disabled) return;
      if (gameMode === "campaign-room" && campaignState && campaignState.blockHint1Until && Date.now() < campaignState.blockHint1Until) {
        const remain = Math.ceil((campaignState.blockHint1Until - Date.now()) / 1000);
        setCampaignStatus(`üîí Pista 1 bloqueada durante ${remain}s.`);
        return;
      }
      setCampaignStatus("");
      hint1El.classList.toggle("visible");
      // Bendici√≥n M1: al ABRIR Pista 1, +10s (1 vez por acertijo)
      if (gameMode === "campaign-room" && campaignState) {
        const isVisible = hint1El.classList.contains("visible");
        if (isVisible && campaignState.turnFlags && !campaignState.turnFlags.openedHint1) {
          campaignState.turnFlags.openedHint1 = true;
          if (campaignState.activeCmdKey === "No tendr√°s otros dioses") {
            campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) + 10);
            updateTimerUI();
            setCampaignStatus("‚ú® Bendici√≥n (M1): +10s al abrir Pista 1.");
          }
        }
      }

    });
  }
if (hint2Btn && hint2El) {
    hint2Btn.addEventListener("click", () => {
      if (hint2Btn.disabled) return;
      if (isHint2Locked()) {
        setCampaignStatus("üîí Pista 2 requiere que el jugador activo gaste su s√≠mbolo (Pista 2) en el m√≥vil.");
        return;
      }
      setCampaignStatus("");
      hint2El.classList.toggle("visible");
    });
  }
if (solutionBtn && solutionEl) {
    solutionBtn.addEventListener("click", () => {
      if (!solutionBtn.disabled) {
        solutionEl.classList.toggle("visible");
      }
    });
  }

  if (nextBtn) {
    nextBtn.addEventListener("click", () => {
      const room = rooms[currentRoomKey];
      if (!room || !room.puzzles || room.puzzles.length === 0) return;
      currentPuzzleIndex = (currentPuzzleIndex + 1) % room.puzzles.length;
      loadPuzzle();
    });
  }

  if (prevBtn) {
    prevBtn.addEventListener("click", () => {
      const room = rooms[currentRoomKey];
      if (!room || !room.puzzles || room.puzzles.length === 0) return;
      const total = room.puzzles.length;
      currentPuzzleIndex = (currentPuzzleIndex - 1 + total) % total;
      loadPuzzle();
    });
  }

  if (toggleSolvedBtn) {
    toggleSolvedBtn.addEventListener("click", toggleSolvedCurrentPuzzle);
  }

  if (backToBoardBtn) {
    backToBoardBtn.addEventListener("click", () => {
      if (gameMode === "campaign-room") showBoard();
      else showHome();
    });
  }
  
	if (boardSection) {
	  boardSection.addEventListener("change", (ev) => {
		const select = ev.target.closest(".sin-select");
		if (!select || !campaignState) return;

		const playerId = parseInt(select.dataset.playerId, 10);
		const player = campaignState.players.find(p => p.id === playerId);
		if (!player) return;

		const chosen = select.value || null;
		player.sin = chosen;

		renderPlayersSummary();
	  });
	}

	if (playersSummaryEl) {
	  playersSummaryEl.addEventListener("click", (ev) => {
		const btn = ev.target.closest(".btn-open-sin-picker");
		if (!btn) return;
		const playerId = Number(btn.dataset.playerId);
		openSinOverlayForPlayer(playerId);
	  });
	}

	if (roomMusicToggleBtn) {
	  roomMusicToggleBtn.addEventListener("click", () => {
		roomMusicMuted = !roomMusicMuted;

		if (roomMusicMuted) {
		  stopAudio(); // parar m√∫sica de sala
		  roomMusicToggleBtn.textContent = "üîá M√∫sica de la sala: OFF";
		} else {
		  playRoomMusic(); // reanudar m√∫sica de sala actual
		  roomMusicToggleBtn.textContent = "üîä M√∫sica de la sala: ON";
		}
	  });
	}

  
  let currentPuzzleIndex = 0;
  let gameMode = "home"; // "home", "campaign-setup", "campaign-board", "campaign-room", "free", "rules"
  let bgMusicMuted = false; // false = suena, true = apagada

  const STORAGE_KEY = "archivum_solved_v1";
  // --- Par√°metros de URL (necesarios antes de mostrar la vista inicial) ---
  const urlParams = new URLSearchParams(location.search);
  const appMode = urlParams.get("mode") === "player" ? "player" : "host";
  const roomFromUrl = (urlParams.get("room") || "").toUpperCase();

  let solvedMap = {};
  let campaignState = null;
  let roomMusicMuted = false; // controla solo la m√∫sica de las salas

  const rooms = ROOMS_DATA;

// ---------------------------
// Dificultad (filtrado campa√±a)
// ---------------------------
function getSelectedDifficulty() {
  // Fuente de verdad: Firestore (room.difficulty). Fallback: estado local.
  const d = (multiplayer && multiplayer.latestRoom && multiplayer.latestRoom.difficulty)
    ? multiplayer.latestRoom.difficulty
    : (campaignState && campaignState.difficulty ? campaignState.difficulty : "auto");
  return (d || "auto");
}

function normalizeDifficultyTag(s) {
  if (!s) return "";
  let t = String(s).trim().toLowerCase();
  try { t = t.normalize("NFD").replace(/[ÃÄ-ÕØ]/g, ""); } catch (_) {}
  return t;
}

function puzzleMatchesDifficulty(puzzle, selected) {
  const sel = normalizeDifficultyTag(selected || "auto");
  if (!sel || sel === "auto") return true;

  const d = normalizeDifficultyTag(puzzle && puzzle.difficulty ? puzzle.difficulty : "");

  // Valores actuales en puzzles_roles_final.js:
  // - "F√°cil", "F√°cil‚Äìmedia", "Media", "Media‚Äìdif√≠cil"
  if (sel === "easy") return d.includes("facil");     // incluye "facil-media"
  if (sel === "normal") return d === "media";
  if (sel === "hard") return d.includes("dificil");   // incluye "media-dificil"
  return true;
}

function difficultyLabel(sel) {
  const s = String(sel || "auto");
  if (s === "easy") return "F√°cil";
  if (s === "normal") return "Media";
  if (s === "hard") return "Dif√≠cil";
  return "Mixta";
}

  let currentRoomKey = null;

// --- INICIO ---
  loadSolvedFromStorage();
  updateSidebarRoomCounters();
  updateGlobalSolvedSummary();
// =========================
  // MULTIJUGADOR (Host + M√≥viles)
  // =========================
  // Uso:
  // - Host: abre la web normal (sin par√°metros) y crea partida.
  // - Jugador: abre ?mode=player&room=ABCD (v√≠a QR/enlace).
  //
  // Requiere Firebase (Firestore). Rellena FIREBASE_CONFIG.
  // (URL params ya le√≠dos arriba: appMode, roomFromUrl)
  // ‚ö†Ô∏è Rellena esto con tu config de Firebase
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyDrWVQQEO-h8KKi37_sjwDl6WeApOBMEcA",
    authDomain: "archivum-87947.firebaseapp.com",
    projectId: "archivum-87947",
    storageBucket: "archivum-87947.firebasestorage.app",
    messagingSenderId: "279795022764",
    appId: "1:279795022764:web:d40e06233bd54ead67ac09",
    measurementId: "G-GGGL3CZ695"
  };

  const multiplayer = {
    enabled: true,
    roomCode: null,
    roomRef: null,
    playersUnsub: null,
    roomUnsub: null,
    actionsUnsub: null,
    latestRoom: null,
    publishedPuzzleCode: null,
    playerListUnsub: null,
    playerList: [],
    isReady: false,
    hostPlayers: [],   // [{id, name, seatNumber, sinChosen}]
    player: {
      id: null,
      name: null,
      seatNumber: null,
      pickNumber: null,
      commandmentKey: null,
      sinKey: null,
    }
  };

  function hasFirebaseConfig() {
    return !!(FIREBASE_CONFIG && FIREBASE_CONFIG.apiKey && FIREBASE_CONFIG.projectId);
  }

  function ensureFirebase() {
    if (!hasFirebaseConfig()) return null;
    if (!window.firebase || !firebase.apps) return null;
    if (!firebase.apps.length) firebase.initializeApp(FIREBASE_CONFIG);
    return firebase.firestore();
  }

  function genRoomCode(len = 4) {
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // sin 0/O/1/I para evitar confusiones
    let out = "";
    for (let i = 0; i < len; i++) out += alphabet[Math.floor(Math.random() * alphabet.length)];
    return out;
  }

  function shuffleLocal(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Elementos UI nuevos
  const joinSection = document.getElementById("campaignJoinSection");
  const joinCodeText = document.getElementById("joinCodeText");
  const joinLinkText = document.getElementById("joinLinkText");
  const qrWrap = document.getElementById("qrWrap");
  const joinedCountEl = document.getElementById("joinedCount");
  const maxCountEl = document.getElementById("maxCount");
  const startSinRitualBtn = document.getElementById("startSinRitualBtn");
  const joinCancelBtn = document.getElementById("joinCancelBtn");
  const joinStatusText = document.getElementById("joinStatusText");
  const copyJoinLinkBtn = document.getElementById("copyJoinLinkBtn");

  const playerSection = document.getElementById("playerSection");
  const playerNameInput = document.getElementById("playerNameInput");
  const playerJoinBtn = document.getElementById("playerJoinBtn");
  const playerJoinError = document.getElementById("playerJoinError");
  const playerJoinCard = document.getElementById("playerJoinCard");
  const playerInfoCard = document.getElementById("playerInfoCard");

  const playerPickNumber = document.getElementById("playerPickNumber");
  const playerCommandmentName = document.getElementById("playerCommandmentName");
  const playerCommandmentImg = document.getElementById("playerCommandmentImg");
  const playerCommandmentDesc = document.getElementById("playerCommandmentDesc");

  const playerSinName = document.getElementById("playerSinName");
  const playerSinBody = document.getElementById("playerSinBody");
  const playerSinImg = document.getElementById("playerSinImg");
  const playerSinDesc = document.getElementById("playerSinDesc");
  const playerSinHint = document.getElementById("playerSinHint");
  const playerOpenSinPickerBtn = document.getElementById("playerOpenSinPickerBtn");
  const playerPhaseText = document.getElementById("playerPhaseText");

  // Overlay "ritual" (host): reutilizamos el sinOverlay como overlay general con mensaje,
  // pero dejamos el carrusel solo para jugador (m√≥vil).
  // Si en un futuro quieres un overlay distinto, lo separamos en otro div.
  function showJoinSectionHost(roomCode, joinUrl, maxPlayers) {
  transitionTo(() => {
      if (!joinSection) return;
      showView(joinSection);
      if (appRoot) appRoot.classList.remove("home-mode");
      if (sidebar) sidebar.style.display = "none";
    
      joinCodeText.textContent = roomCode;
      joinLinkText.textContent = joinUrl;
      copyJoinLinkBtn.disabled = false;
    
      joinedCount.textContent = "0";
      maxCount.textContent = String(maxPlayers || 0);
      joinStatusText.textContent = "";
      startSinRitualBtn.disabled = true;
    
      // Genera QR (si librer√≠a disponible)
      try {
        if (typeof QRCode !== "undefined" && qrWrap) {
          qrWrap.innerHTML = "";
          new QRCode(qrWrap, {
            text: joinUrl,
            width: 180,
            height: 180,
            colorDark: "#d2af6e",
            colorLight: "#00000000",
            correctLevel: QRCode.CorrectLevel.M
          });
        }
      } catch (e) {
        // Si falla el QR, no pasa nada (el enlace sigue funcionando).
      }
  });
}


  function showPlayerMode() {
  transitionTo(() => {
      showView(playerSection);
    // Modo jugador: sin m√∫sica ni controles (evita solape con el host)
    stopAudio();
    stopBackgroundMusic();
    try { if (roomAudioEl) roomAudioEl.pause(); } catch(e) {}
    bgMusicMuted = true;
    roomMusicMuted = true;
    if (globalMusicToggleContainer) globalMusicToggleContainer.style.display = "none";
    if (roomMusicToggleContainer) roomMusicToggleContainer.style.display = "none";
      if (sidebar) sidebar.style.display = "none";
      if (appRoot) appRoot.classList.remove("home-mode");
      if (appRoot) requestAnimationFrame(() => appRoot.classList.remove("booting"));
  });
}



  function setJoinStatus(text) {
    if (!joinStatusText) return;
    joinStatusText.textContent = text || "";
    joinStatusText.classList.remove("fade-pop");
    void joinStatusText.offsetWidth;
    joinStatusText.classList.add("fade-pop");
  }

  // --- Helpers de UI: transiciones entre pantallas ---
  function getMainViews() {
    return [
      document.getElementById("homeSection"),
      document.getElementById("campaignSetupSection"),
      document.getElementById("rulesSection"),
      document.getElementById("campaignJoinSection"),
      document.getElementById("playerSection"),
      document.getElementById("campaignRolesSection"),
      document.getElementById("campaignBoardSection"),
      document.getElementById("roomSection")
    ].filter(Boolean);
  }

function isVisible(el) {
    return !!el && el.style.display !== "none";
  }

  
  const fadeOverlay = document.getElementById("fadeOverlay");
  let __isFading = false;
  let __hasBooted = false;

  function fadeTo(actionFn){
  if (!fadeOverlay) { actionFn(); return; }
  if (__isFading) { actionFn(); return; }
  __isFading = true;

  let doneCalled = false;

  const runAction = () => {
    if (doneCalled) return;
    doneCalled = true;
    try {
      actionFn();
    } finally {
      // Peque√±a pausa "en negro" para que no se vea el cambio de layout
      setTimeout(() => {
        fadeOverlay.classList.remove("is-on");

        const unlock = () => { __isFading = false; };
        fadeOverlay.addEventListener("transitionend", unlock, { once: true });
        setTimeout(unlock, 450);
      }, 80);
    }
  };

  // Ejecuta la acci√≥n cuando el overlay ya est√° completamente opaco
  fadeOverlay.addEventListener("transitionend", runAction, { once: true });

  // Arrancamos el fade a negro en el siguiente frame para asegurar transici√≥n
  requestAnimationFrame(() => {
    fadeOverlay.classList.add("is-on");
  });

  // Fallback por si transitionend no dispara (p.ej. tab en background)
  setTimeout(runAction, 380);
}



function transitionTo(actionFn, opts){
  opts = opts || {};
  // Primera carga: sin fundido para evitar flashes
  if (!__hasBooted) { __hasBooted = true; actionFn(); return; }
  if (opts.instant) { actionFn(); return; }
  fadeTo(actionFn);
}

function hideView(el) {
    if (!el) return;
    // Evita warnings de accesibilidad: si algo dentro tiene el foco, lo quitamos antes de ocultar.
    try {
      const ae = document.activeElement;
      if (ae && ae !== document.body && el.contains(ae)) ae.blur();
    } catch (e) {}
    el.style.display = 'none';
    el.setAttribute('aria-hidden', 'true');
    el.classList.add('view-hidden');
  }

  function showView(el) {
    setRitualOverlay("", false);
    if (!el) return;

    // Oculta otras vistas principales (sin animaci√≥n propia)
    getMainViews().forEach(v => { if (v !== el) hideView(v); });

    // Muestra objetivo
    el.style.display = "block";
    el.setAttribute("aria-hidden", "false");
    el.classList.remove("view-hidden");
  }


  // --- Ritual overlay ---
  function setRitualOverlay(message, visible) {
    const overlay = document.getElementById("ritualOverlay");
    const textEl = document.getElementById("ritualText");
    if (!overlay || !textEl) return;

    textEl.textContent = message || "";
    if (visible) {
      overlay.classList.add("ritual-visible");
      overlay.setAttribute("aria-hidden", "false");
    } else {
      overlay.classList.remove("ritual-visible");
      overlay.setAttribute("aria-hidden", "true");
    }
  }


  function setPlayerError(text) {
    if (!playerJoinError) return;
    playerJoinError.style.display = text ? "block" : "none";
    playerJoinError.textContent = text || "";
  }

  function computeJoinUrl(roomCode) {
    const base = location.origin + location.pathname;
    return `${base}?mode=player&room=${encodeURIComponent(roomCode)}`;
  }

  // Firestore schema:
  // rooms/{code}: { phase: "joining"|"sin-picking"|"playing", playersMax, seatsTaken, pickQueue: [1..N], pickCursor, assignedPickNumbers:[], assignedCommandments:[] }
  // rooms/{code}/players/{playerId}: { name, seatNumber, pickNumber, commandmentKey, sinKey, solved }
  async function hostCreateRoom(db, { playersMax, puzzlesPerRoom, timeLimitSec, difficulty }) {
    const code = genRoomCode(4);
    const pickQueue = shuffleLocal(Array.from({ length: playersMax }, (_, i) => i + 1));

    const roomRef = db.collection("rooms").doc(code);
    await roomRef.set({
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      phase: "joining",
      playersMax,
      puzzlesPerRoom,
      seatsTaken: 0,
      pickQueue,
      pickCursor: 0,
      assignedPickNumbers: [],
      assignedCommandments: [],
      // --- estado de partida (reseteado siempre al crear partida) ---
      difficulty: difficulty || "auto",
      timeLimitSec: (typeof timeLimitSec === "number" ? timeLimitSec : 180),
      attemptsMax: 2,
      // --- runtime (se inicia en "idle") ---
      activeSeatNumber: null,
      turnCounter: 0,
      currentPuzzleCode: null,
      currentRoomKey: null,
      hint2Unlocked: false,
      turnTokenUsed: false,
      pendingPenalties: {},
      roomSolvedTotals: {},
      solvedAttribution: {},
      lastSinApplied: null,
      lastSinAppliedAt: null,

    });

    return { code, roomRef };
  }

  async function playerJoinRoom(db, roomCode, playerName) {
    const roomRef = db.collection("rooms").doc(roomCode);

    // token persistente por sala
    const tokenKey = `archivum_player_${roomCode}`;
    let playerId = localStorage.getItem(tokenKey);
    if (!playerId) {
      playerId = "p_" + Math.random().toString(36).slice(2, 10);
      localStorage.setItem(tokenKey, playerId);
    }

    const playerRef = roomRef.collection("players").doc(playerId);

    // Si ya existe, lo reutilizamos (reconexi√≥n)
    const existing = await playerRef.get();
    if (existing.exists) {
      const data = existing.data() || {};
      return { playerId, playerRef, data };
    }

    // Asignaci√≥n at√≥mica (n√∫mero secreto + mandamiento + asiento)
    const result = await db.runTransaction(async (tx) => {
      const snap = await tx.get(roomRef);
      if (!snap.exists) throw new Error("No existe esa partida.");
      const room = snap.data();

      if (room.phase !== "joining") {
        throw new Error("La partida ya ha empezado. Pide al host un nuevo c√≥digo.");
      }

      const playersMax = room.playersMax || 7;
      const seatsTaken = room.seatsTaken || 0;
      if (seatsTaken >= playersMax) throw new Error("La partida est√° completa.");

      const assignedPick = new Set(room.assignedPickNumbers || []);
      const availablePick = [];
      for (let i = 1; i <= playersMax; i++) if (!assignedPick.has(i)) availablePick.push(i);
      if (!availablePick.length) throw new Error("No quedan n√∫meros disponibles.");

      const assignedCmd = new Set(room.assignedCommandments || []);
      const availableCmd = COMMANDMENTS.filter(k => !assignedCmd.has(k));
      if (!availableCmd.length) throw new Error("No quedan mandamientos disponibles.");

      const pickNumber = availablePick[Math.floor(Math.random() * availablePick.length)];
      const commandmentKey = availableCmd[Math.floor(Math.random() * availableCmd.length)];
      const seatNumber = seatsTaken + 1;

      tx.set(playerRef, {
        name: playerName,
        seatNumber,
        pickNumber,
        commandmentKey,
        sinKey: null,
        solved: 0,
        joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
      });

      tx.update(roomRef, {
        seatsTaken: seatNumber,
        assignedPickNumbers: firebase.firestore.FieldValue.arrayUnion(pickNumber),
        assignedCommandments: firebase.firestore.FieldValue.arrayUnion(commandmentKey),
      });

      return { playerId, seatNumber, pickNumber, commandmentKey };
    });

    return { playerId: result.playerId, playerRef, data: result };
  }

  function hostListenRoom(db, roomCode) {
    multiplayer.roomCode = roomCode;
    multiplayer.roomRef = db.collection("rooms").doc(roomCode);

    // Acciones del m√≥vil -> host (Pista 2 o Poder). Se consumen (1 s√≠mbolo por turno).
    if (multiplayer.actionsUnsub) multiplayer.actionsUnsub();
    multiplayer.actionsUnsub = multiplayer.roomRef.collection("actions").orderBy("clientTs").onSnapshot((qs) => {
      qs.docChanges().forEach(async (ch) => {
        if (ch.type !== "added") return;
        const actionRef = ch.doc.ref;
        const a = ch.doc.data() || {};
        try { await hostHandleAction(db, a); } catch (e) {}
        // limpiar acci√≥n para evitar re-procesado
        actionRef.delete().catch(()=>{});
      });
    });

    // Room listener
    multiplayer.roomUnsub = multiplayer.roomRef.onSnapshot((snap) => {
      if (!snap.exists) return;
      const room = snap.data() || {};
      multiplayer.latestRoom = room;

      const seatsTaken = room.seatsTaken || 0;
      const playersMax = room.playersMax || 0;
      if (joinedCountEl) joinedCountEl.textContent = String(seatsTaken);
      if (maxCountEl) maxCountEl.textContent = String(playersMax);

      // Habilitar bot√≥n cuando est√©n todos
      if (startSinRitualBtn) startSinRitualBtn.disabled = !(seatsTaken >= playersMax && room.phase === "joining");

      // Ritual host: mostrar mensaje en rolesSection (usamos sinOverlayTitle para texto grande)
      if (room.phase === "sin-picking") {
        const currentNumber = (room.pickQueue && room.pickQueue[room.pickCursor]) || null;
        // Mostramos un overlay "oscuro" sin carrusel
        sinOverlayTitle.textContent = currentNumber
          ? `Todos cerrad los ojos. El N√öMERO ${currentNumber} elige pecado.`
          : "Preparando selecci√≥n de pecados‚Ä¶";
        // ocultamos el bot√≥n de cerrar para que no sea confuso en host
        if (sinOverlayClose) sinOverlayClose.style.display = "none";
        if (sinCarousel) sinCarousel.style.display = "none";
        sinOverlay.classList.remove("sin-overlay--hidden");
      } else {
        // oculta overlay si no estamos en ritual
        if (sinOverlayClose) sinOverlayClose.style.display = "";
        if (sinCarousel) sinCarousel.style.display = "";
        sinOverlay.classList.add("sin-overlay--hidden");
      }

      if (room.phase === "playing") {
        // Entrar al tablero (host) ‚Äî IMPORTANTE: no re-inicializar en cada cambio del doc
        multiplayer.isReady = true;

        if (!multiplayer._bootstrappedPlaying) {
          multiplayer._bootstrappedPlaying = true;

          // Construye un campaignState m√≠nimo p√∫blico (solo 1 vez al entrar en playing)
          const players = (multiplayer.hostPlayers || []).slice()
            .sort((a,b)=> (a.seatNumber||0)-(b.seatNumber||0))
            .map(p => ({ id: p.seatNumber, name: p.name, solved: p.solved || 0, sinChosen: !!p.sinKey }));

          campaignState = {
            players,
            activePlayerIndex: 0,
            hideSecretsOnHost: true,
            phase: "playing",
            puzzlesPerRoom: room.puzzlesPerRoom || 3,
            roomSolvedTotals: {},
            solvedAttribution: {},
            lastLoadedCode: null,
            lastLoadedRoomKey: null,
            autoPassTurn: true,
            attemptsMax: 2,
            attemptsRemaining: 2,
            hint2Unlocked: false,
            turnTokenUsed: false,
            ignoreNextTimePenaltyOnce: false,
            blockHint1Until: 0,
            // Dificultad (filtra c√≥digos v√°lidos)
            difficulty: (room.difficulty || "auto"),
            // Tiempo l√≠mite por acertijo (configurable en host)
            timeLimitSec: (room.timeLimitSec || 180),
            timerEnabled: true,
            timerRemaining: (room.timeLimitSec || 180),
            timerIntervalId: null,
          };
        } else {
          // Mant√©n config en sync si el host cambia puzzlesPerRoom
          if (campaignState) {
            campaignState.puzzlesPerRoom = room.puzzlesPerRoom || campaignState.puzzlesPerRoom;
            campaignState.timeLimitSec = (room.timeLimitSec || campaignState.timeLimitSec || 180);
            campaignState.difficulty = (room.difficulty || campaignState.difficulty || "auto");
          }
        }

        // No forzar vuelta al tablero si el host est√° dentro del acertijo
        if (appMode !== "player" && gameMode !== "campaign-room") {
          showBoard();
        }
      }
    });

    // Players listener
    multiplayer.playersUnsub = multiplayer.roomRef.collection("players").onSnapshot((qs) => {
      const list = [];
      qs.forEach(doc => {
        const d = doc.data() || {};
        list.push({ id: doc.id, ...d });
      });
      multiplayer.hostPlayers = list;

      // Texto de estado host
      const picked = list.filter(p => !!p.sinKey).length;
      if (setJoinStatus) {
        setJoinStatus(picked ? `Pecados elegidos: ${picked}/${list.length}` : "");
      }

      // Auto-avanzar el cursor cuando el n√∫mero actual ya eligi√≥
      // (Esto evita que el host tenga que pulsar "Siguiente")
      // Nota: el cursor avanza cuando detecta que el jugador con pickNumber actual tiene sinKey.
      // Con pocos jugadores, hacerlo por snapshot es suficiente.
      advancePickCursorIfNeeded(db);

      // Si ya estamos jugando, re-render del panel p√∫blico
      if (campaignState && campaignState.hideSecretsOnHost) {
        renderPlayersSummaryHostPublic();
      }
    });
  }

  async function advancePickCursorIfNeeded(db) {
    if (!multiplayer.roomRef) return;
    const snap = await multiplayer.roomRef.get();
    if (!snap.exists) return;
    const room = snap.data() || {};
    if (room.phase !== "sin-picking") return;

    const playersMax = room.playersMax || 0;
    const pickQueue = room.pickQueue || [];
    const cursor = room.pickCursor || 0;
    const currentNumber = pickQueue[cursor];
    if (!currentNumber) return;

    // ¬øYa eligi√≥ el jugador con ese n√∫mero?
    const list = multiplayer.hostPlayers || [];
    const currentPlayer = list.find(p => p.pickNumber === currentNumber);
    if (!currentPlayer) return; // todav√≠a no est√° ese n√∫mero unido (raro, pero posible)
    if (!currentPlayer.sinKey) return;

    // Avanza cursor en transacci√≥n para evitar carreras
    await db.runTransaction(async (tx) => {
      const fresh = await tx.get(multiplayer.roomRef);
      if (!fresh.exists) return;
      const r = fresh.data() || {};
      if (r.phase !== "sin-picking") return;

      const c = r.pickCursor || 0;
      const q = r.pickQueue || [];
      const curNum = q[c];
      if (curNum !== currentNumber) return; // ya cambi√≥

      const nextCursor = c + 1;
	      if (nextCursor >= (r.playersMax || 0)) {
	        tx.update(multiplayer.roomRef, { pickCursor: nextCursor, phase: "playing", activeSeatNumber: 1, turnTokenUsed: false, hint2Unlocked: false, currentPuzzleCode: null, currentRoomKey: null, turnCounter: 1, timeLimitSec: (r.timeLimitSec || 180), attemptsMax: 2, pendingPenalties: {} });
	      } else {
        tx.update(multiplayer.roomRef, { pickCursor: nextCursor });
      }
    });
  }

  async function hostStartSinRitual(db) {
    if (!multiplayer.roomRef) return;
    await multiplayer.roomRef.update({ phase: "sin-picking", pickCursor: 0 });
  }

  function playerListenRoom(db, roomCode, playerRef) {
    const roomRef = db.collection("rooms").doc(roomCode);

    // Lista de jugadores (para seleccionar objetivo de Tentaci√≥n)
    if (multiplayer.playerListUnsub) multiplayer.playerListUnsub();
    multiplayer.playerListUnsub = roomRef.collection("players").onSnapshot((qs) => {
      const list = [];
      qs.forEach(doc => {
        const d = doc.data() || {};
        if (d.seatNumber) {
          list.push({
            seatNumber: d.seatNumber,
            name: d.name || (`Jugador ${d.seatNumber}`)
          });
        }
      });
      list.sort((a,b)=> (a.seatNumber||0)-(b.seatNumber||0));
      multiplayer.playerList = list;
    });


    // Player doc listener (para reflejar cambios)
    playerRef.onSnapshot((snap) => {
      if (!snap.exists) return;
      const d = snap.data() || {};
      multiplayer.player.name = d.name || multiplayer.player.name;
      multiplayer.player.seatNumber = d.seatNumber || multiplayer.player.seatNumber;
      multiplayer.player.pickNumber = d.pickNumber || multiplayer.player.pickNumber;
      multiplayer.player.commandmentKey = d.commandmentKey || multiplayer.player.commandmentKey;
      multiplayer.player.sinKey = d.sinKey || null;

      // Render identidad
      playerJoinCard.style.display = "none";
      playerInfoCard.style.display = "block";

      playerPickNumber.textContent = multiplayer.player.pickNumber ? String(multiplayer.player.pickNumber) : "‚Äî";

      const cmdKey = multiplayer.player.commandmentKey;
      playerCommandmentName.textContent = cmdKey || "‚Äî";
      const cmdInfo = cmdKey ? (COMMANDMENT_META[cmdKey] || null) : null;

      // Mostrar imagen si existe, pero NO ocultar el texto si falta el PNG.
      if (cmdInfo && cmdInfo.image) {
        playerCommandmentImg.src = cmdInfo.image;
        playerCommandmentImg.alt = cmdKey;
        playerCommandmentImg.style.display = "";
      } else {
        playerCommandmentImg.style.display = "none";
      }

      playerCommandmentDesc.innerHTML = cmdInfo ? (
        `${cmdInfo.blessing ? `<strong>Bendici√≥n:</strong> ${cmdInfo.blessing}<br>` : ""}` +
        `${cmdInfo.vow ? `<strong>${cmdInfo.vow.title}:</strong> ${cmdInfo.vow.text}<br>` : ""}` +
        `${cmdInfo.power ? `<strong>${cmdInfo.power.title}:</strong> ${cmdInfo.power.text}` : ""}`
      ) : "‚Äî";

      if (multiplayer.player.sinKey) {
        const sinInfo = SIN_META[multiplayer.player.sinKey] || null;
        playerSinName.textContent = sinInfo ? sinInfo.key : multiplayer.player.sinKey;

        // Mostrar siempre que ya hay pecado elegido (aunque falte metadata).
        playerSinBody.style.display = "flex";
        if (sinInfo) {
          playerSinImg.style.display = "";
          playerSinImg.src = sinInfo.img;
          playerSinImg.alt = sinInfo.key;
          playerSinDesc.innerHTML =
            `${sinInfo.advantage ? `<strong>Ventaja:</strong> ${sinInfo.advantage}<br>` : ""}` +
            `${sinInfo.cost ? `<strong>Coste:</strong> ${sinInfo.cost}<br>` : ""}` +
            `${sinInfo.temptation ? `<strong>${sinInfo.temptation.title}:</strong> ${sinInfo.temptation.text}` : ""}`;
        } else {
          playerSinImg.style.display = "none";
          playerSinDesc.textContent = "‚Äî";
        }

        playerSinHint.style.display = "none";
        playerOpenSinPickerBtn.style.display = "none";
      } else {
        playerSinName.textContent = "A√∫n sin elegir";
        playerSinBody.style.display = "none";
        playerSinHint.style.display = "";
      }
    });

    // Room doc listener (para saber si es tu turno)
    roomRef.onSnapshot((snap) => {
      if (!snap.exists) return;
      const room = snap.data() || {};
      multiplayer.latestRoom = room;
      const phase = room.phase || "joining";
      const cursor = room.pickCursor || 0;
      const currentNumber = (room.pickQueue && room.pickQueue[cursor]) || null;

      if (phase === "joining") {
        playerPhaseText.textContent = "Esperando a que se unan todos los jugadores‚Ä¶";
        playerOpenSinPickerBtn.style.display = "none";
      } else if (phase === "sin-picking") {
        if (currentNumber && multiplayer.player.pickNumber === currentNumber && !multiplayer.player.sinKey) {
          playerPhaseText.textContent = "¬°Es tu turno! Elige tu pecado y pulsa listo.";
          playerOpenSinPickerBtn.style.display = "";
        } else {
          playerPhaseText.textContent = currentNumber
            ? `Ahora elige el N√öMERO ${currentNumber}. Espera tu turno.`
            : "Selecci√≥n de pecados en curso‚Ä¶";
          playerOpenSinPickerBtn.style.display = "none";
        }
      } else if (phase === "playing") {
        // Estado general
        playerPhaseText.textContent = "La partida ha comenzado. Consulta aqu√≠ tus rasgos cuando quieras.";
        playerOpenSinPickerBtn.style.display = "none";

        const turnCard = document.getElementById("playerTurnCard");
        const turnStatus = document.getElementById("playerTurnStatus");
        const btnHint2 = document.getElementById("playerUnlockHint2Btn");
        const btnCmd = document.getElementById("playerUseCommandmentPowerBtn");
        const btnSin = document.getElementById("playerUseSinPowerBtn");

        const activeSeat = room.activeSeatNumber || null;
        const puzzleCode = room.currentPuzzleCode || null;
        const tokenUsed = !!room.turnTokenUsed;

        const isMyTurn = (activeSeat != null && multiplayer.player.seatNumber != null && Number(activeSeat) === Number(multiplayer.player.seatNumber));
        const canAct = isMyTurn && puzzleCode && !tokenUsed;

        if (turnCard) turnCard.style.display = (multiplayer.player && multiplayer.player.seatNumber) ? "" : "none";
        if (turnStatus) {
          if (!puzzleCode) turnStatus.textContent = "A√∫n no hay un acertijo activo en el host.";
          else if (!isMyTurn) turnStatus.textContent = `Turno del jugador ${activeSeat}.`;
          else if (tokenUsed) turnStatus.textContent = "Tu s√≠mbolo ya se ha gastado este turno.";
          else turnStatus.textContent = "Tienes 1 s√≠mbolo este turno. Elige: Pista 2 o activar poder.";
        }

        if (btnHint2) btnHint2.disabled = !canAct;
        if (btnCmd) btnCmd.disabled = !canAct;
        if (btnSin) {
          btnSin.style.display = multiplayer.player.sinKey ? "" : "none";
          btnSin.disabled = !canAct || !multiplayer.player.sinKey;
        }

        // listeners (una sola vez)
        if (btnHint2 && !btnHint2.dataset.bound) {
          btnHint2.dataset.bound = "1";
          btnHint2.addEventListener("click", async () => {
            try {
              const db = firebase.firestore();
              const tc = (multiplayer.latestRoom && multiplayer.latestRoom.turnCounter) ? multiplayer.latestRoom.turnCounter : 0;
              await playerSendTurnAction(db, roomCode, { type: "HINT2_UNLOCK", turnCounter: tc });
            } catch (e) {
              alert("No se pudo enviar la acci√≥n.");
            }
          });
        }

        if (btnCmd && !btnCmd.dataset.bound) {
          btnCmd.dataset.bound = "1";
          btnCmd.addEventListener("click", async () => {
            try {
              const db = firebase.firestore();
              const tc = (multiplayer.latestRoom && multiplayer.latestRoom.turnCounter) ? multiplayer.latestRoom.turnCounter : 0;
              await playerSendTurnAction(db, roomCode, { type: "POWER", role: "commandment", key: multiplayer.player.commandmentKey, turnCounter: tc });
            } catch (e) {
              alert("No se pudo enviar la acci√≥n.");
            }
          });
        }

        if (btnSin && !btnSin.dataset.bound) {
          btnSin.dataset.bound = "1";
          btnSin.addEventListener("click", async () => {
            if (!multiplayer.player.sinKey) return;
            // elegir objetivo (m√≥vil)
            const others = (multiplayer.playerList || []).filter(p => p.seatNumber !== multiplayer.player.seatNumber);
            if (!others.length) { alert("No hay objetivo disponible."); return; }
            const targetSeat = await pickTargetSeatFromModal(others);
            if (!targetSeat) return;

            try {
              const db = firebase.firestore();
              const tc = (multiplayer.latestRoom && multiplayer.latestRoom.turnCounter) ? multiplayer.latestRoom.turnCounter : 0;
              await playerSendTurnAction(db, roomCode, { type: "POWER", role: "sin", key: multiplayer.player.sinKey, targetSeat, turnCounter: tc });
            } catch (e) {
              alert("No se pudo enviar la acci√≥n.");
            }
          });
        }
      }
    });
  }

  
  
  // M√≥vil: selector de objetivo (sin prompts del navegador)
  function pickTargetSeatFromModal(others) {
    return new Promise((resolve) => {
      const overlay = document.getElementById("targetPickerOverlay");
      const list = document.getElementById("targetPickerList");
      const cancelBtn = document.getElementById("targetPickerCancelBtn");

      // Fallback por si el modal no existe por alg√∫n motivo
      if (!overlay || !list || !cancelBtn) {
        const options = others.map(p => `${p.seatNumber} ‚Äî ${p.name}`).join("\n");
        const input = prompt(`Elige objetivo (escribe el n√∫mero):\n${options}`);
        if (!input) return resolve(null);
        const targetSeat = parseInt(input, 10);
        return resolve(Number.isFinite(targetSeat) ? targetSeat : null);
      }

      let closed = false;

      const close = (value) => {
        if (closed) return;
        closed = true;
        overlay.style.display = "none";
        overlay.setAttribute("aria-hidden", "true");
        list.innerHTML = "";
        cancelBtn.onclick = null;
        overlay.onclick = null;
        document.removeEventListener("keydown", onKeyDown);
        resolve(value ?? null);
      };

      const onKeyDown = (e) => {
        if (e.key === "Escape") close(null);
      };

      overlay.setAttribute("aria-hidden", "false");
      overlay.style.display = "flex";

      // Construir lista
      list.innerHTML = "";
      others
        .slice()
        .sort((a,b)=> (a.seatNumber||0) - (b.seatNumber||0))
        .forEach((p) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "modal-target-btn";

          const left = document.createElement("div");
          const nameEl = document.createElement("strong");
          nameEl.textContent = p.name || `Jugador ${p.seatNumber}`;
          const seatEl = document.createElement("small");
          seatEl.textContent = `Jugador ${p.seatNumber}`;
          left.appendChild(nameEl);
          left.appendChild(seatEl);

          const arrow = document.createElement("div");
          arrow.textContent = "‚Üí";
          arrow.style.opacity = "0.85";
          arrow.style.fontWeight = "700";

          btn.appendChild(left);
          btn.appendChild(arrow);

          btn.addEventListener("click", () => close(p.seatNumber));
          list.appendChild(btn);
        });

      cancelBtn.onclick = () => close(null);
      overlay.onclick = (e) => { if (e.target === overlay) close(null); };
      document.addEventListener("keydown", onKeyDown);
    });
  }

async function playerSendTurnAction(db, roomCode, payload) {
    const roomRef = db.collection("rooms").doc(roomCode);
    const data = Object.assign({}, payload, {
      seatNumber: multiplayer.player.seatNumber || null,
      clientTs: Date.now()
    });
    await roomRef.collection("actions").add(data);
  }
async function playerChooseSin(db, roomCode, sinKey) {
    const tokenKey = `archivum_player_${roomCode}`;
    const playerId = localStorage.getItem(tokenKey);
    if (!playerId) throw new Error("No est√°s unido a la partida.");
    const playerRef = db.collection("rooms").doc(roomCode).collection("players").doc(playerId);
    await playerRef.update({ sinKey });
  }

  // Host panel p√∫blico (sin secretos)
  function renderPlayersSummaryHostPublic() {
    if (!playersSummaryEl || !campaignState) return;
    playersSummaryEl.innerHTML = "";
    (multiplayer.hostPlayers || [])
      .slice()
      .sort((a,b)=> (a.seatNumber||0)-(b.seatNumber||0))
      .forEach((p, idx) => {
        const wrapper = document.createElement("section");
        wrapper.className = "player-row";
        const isActive = (campaignState.activePlayerIndex === idx);
        wrapper.style.outline = (campaignState.phase === "playing" && isActive) ? "2px solid var(--accent)" : "none";

        const sinState = p.sinKey ? "‚úÖ Pecado elegido" : "‚è≥ Sin elegir";
        wrapper.innerHTML = `
          <strong>${p.name || ("Jugador " + (idx+1))}</strong>
          <span>${sinState} ¬∑ Resueltos: ${p.solved || 0}</span>
        `;
        playersSummaryEl.appendChild(wrapper);
      });
  }

  // Hook: si estamos en host y hideSecretsOnHost, sustituimos el render normal
  const _origShowBoard = showBoard;
  showBoard = function() {
    _origShowBoard();
    if (campaignState && campaignState.hideSecretsOnHost) {
      renderPlayersSummaryHostPublic();
      // Asegura que tablero/controls solo se ven cuando playing
      if (boardMain) boardMain.style.display = "";
      if (boardControls) boardControls.style.display = "";
    }
  };

  // Inicializaci√≥n por modo
  if (appMode === "player") {
    
    document.body.classList.add("player-mode");
showPlayerMode();
    // Reenganche autom√°tico: si ya te uniste antes en este dispositivo, no pedimos nombre otra vez.
    (async () => {
      try {
        if (!roomFromUrl) return;
        const db0 = ensureFirebase();
        if (!db0) return;
        const tokenKey = `archivum_player_${roomFromUrl}`;
        const existingId = localStorage.getItem(tokenKey);
        if (!existingId) return;

        const roomRef = db0.collection("rooms").doc(roomFromUrl);
        const playerRef = roomRef.collection("players").doc(existingId);
        const snap = await playerRef.get();
        if (!snap.exists) return;

        // Oculta el formulario y entra directamente
        if (playerJoinCard) playerJoinCard.style.display = "none";
        if (playerInfoCard) playerInfoCard.style.display = "block";
        playerListenRoom(db0, roomFromUrl, playerRef);
      } catch (e) {
        // si falla, dejamos el flujo normal de "Unirse"
      }
    })();

    if (!roomFromUrl) setPlayerError("Falta el c√≥digo de partida en el enlace.");
    const db = ensureFirebase();
    if (!db) setPlayerError("Falta configurar Firebase (FIREBASE_CONFIG).");

    if (playerJoinBtn) {
      playerJoinBtn.addEventListener("click", async () => {
        try {
          setPlayerError("");
          const name = (playerNameInput.value || "").trim();
          if (!name) { setPlayerError("Escribe tu nombre."); return; }
          if (!roomFromUrl) { setPlayerError("Falta el c√≥digo de partida."); return; }
          const db2 = ensureFirebase();
          if (!db2) { setPlayerError("Firebase no est√° configurado."); return; }

          const { playerRef, data } = await playerJoinRoom(db2, roomFromUrl, name);
          // Arranca listeners
          playerListenRoom(db2, roomFromUrl, playerRef);
        } catch (e) {
          setPlayerError(e.message || "No se pudo unir.");
        }
      });
    }

    // Bot√≥n para abrir selecci√≥n: reutiliza overlay de pecados ya existente
    if (playerOpenSinPickerBtn) {
      playerOpenSinPickerBtn.addEventListener("click", async () => {
        // Abrimos el carrusel, pero sin ‚Äútomados‚Äù visibles (los mostramos como sellados)
        sinSelectionPlayerId = -1; // marcador especial para m√≥vil
        sinOverlayTitle.textContent = "Elige tu pecado";
        // "Tomados" se saca del room.assignedSins para evitar duplicados
        const db2 = ensureFirebase();
        let taken = new Set();
        try {
          const roomSnap = await db2.collection("rooms").doc(roomFromUrl).get();
          const room = roomSnap.exists ? (roomSnap.data() || {}) : {};
          taken = new Set(room.assignedSins || []);
        } catch (e) {
          // si falla, asumimos vac√≠o
          taken = new Set();
        }

        
        function buildSinPickerText(meta){
          if (!meta) return "";
          const parts = [];
          if (meta.advantage) parts.push(`<strong>Ventaja:</strong> ${meta.advantage}`);
          if (meta.cost) parts.push(`<strong>Coste:</strong> ${meta.cost}`);
          const tempt = meta.temptation;
          if (tempt) {
            if (typeof tempt === "string") parts.push(`<strong>Tentaci√≥n:</strong> ${tempt}`);
            else if (tempt.text) parts.push(`<strong>${tempt.title || "Tentaci√≥n"}:</strong> ${tempt.text}`);
          }
          if (!parts.length) {
            const s = meta.short || "";
            const e = meta.effect || "";
            return [s,e].filter(Boolean).join("<br>");
          }
          return parts.join("<br>");
        }

sinCarousel.innerHTML = "";
        Object.values(SIN_META).forEach(meta => {
          const takenByOther = taken.has(meta.key);
          const card = document.createElement("button");
          card.className = "sin-card";
          card.dataset.sin = meta.key;

          if (takenByOther) {
            // Sellado para no dar info por descarte
            card.classList.add("sin-card--taken");
            card.innerHTML = `
              <div class="sin-card-title">Sellado</div>
              <div class="sin-card-text">Este pecado ya ha sido reclamado.</div>
            `;
          } else {
            card.innerHTML = `
              <img src="${meta.img}" alt="${meta.key}">
              <div class="sin-card-title">${meta.key}</div>
              <div class="sin-card-text">
                ${buildSinPickerText(meta)}
              </div>
            `;
          }
          sinCarousel.appendChild(card);
        });

        sinOverlayClose.style.display = ""; // en m√≥vil s√≠ permitimos cerrar
        sinCarousel.style.display = "";
        sinOverlay.classList.remove("sin-overlay--hidden");
      });
    }

    // Click en carta pecado (m√≥vil)
    if (sinCarousel) {
      sinCarousel.addEventListener("click", async (ev) => {
        const card = ev.target.closest(".sin-card");
        if (!card) return;
        if (card.classList.contains("sin-card--taken")) return;
        const chosen = card.dataset.sin;
        try {
          const db2 = ensureFirebase();
          if (!db2) throw new Error("Firebase no est√° configurado.");
          await playerChooseSin(db2, roomFromUrl, chosen);
          sinOverlay.classList.add("sin-overlay--hidden");
        } catch (e) {
          alert(e.message || "No se pudo elegir el pecado.");
        }
      });
    }

  } else {
    // Host (por defecto): al crear campa√±a, se mostrar√° join con QR
    showHome();
    if (joinCancelBtn) joinCancelBtn.addEventListener("click", showHome);

    if (copyJoinLinkBtn) {
      copyJoinLinkBtn.addEventListener("click", async () => {
        try {
          const text = joinLinkText ? joinLinkText.textContent : "";
          if (!text) return;
          await navigator.clipboard.writeText(text);
          setJoinStatus("‚úÖ Enlace copiado.");
          setTimeout(() => setJoinStatus(""), 1500);
        } catch (e) {
          setJoinStatus("No se pudo copiar (tu navegador lo bloque√≥).");
        }
      });
    }

    if (startSinRitualBtn) {
      startSinRitualBtn.addEventListener("click", async () => {
        try {
          const db2 = ensureFirebase();
          if (!db2) { alert("Falta configurar Firebase."); return; }
          await hostStartSinRitual(db2);
        } catch (e) {
          alert(e.message || "No se pudo iniciar el ritual.");
        }
      });
    }

    // Sobrescribimos el bot√≥n Iniciar campa√±a para crear sala y mostrar QR
    if (startCampaignBtn) {
      startCampaignBtn.addEventListener("click", async () => {
        const db2 = ensureFirebase();
        if (!db2) {
          alert("Falta configurar Firebase (FIREBASE_CONFIG). Sin eso, no hay m√≥viles.");
          return;
        }
        const playersMax = Math.max(1, Math.min(7, parseInt(playersCountInput.value, 10) || 1));
        const puzzlesPerRoom = Math.max(1, Math.min(10, parseInt(puzzlesPerRoomInput.value, 10) || 3));
        const timeLimitSec = Math.max(30, Math.min(900, parseInt((timeLimitSecInput && timeLimitSecInput.value) || "180", 10) || 180));
        const difficulty = (puzzleDifficultyInput && puzzleDifficultyInput.value) ? puzzleDifficultyInput.value : "auto";

        // Reset local progreso (modo antiguo) para evitar arrastre visual entre partidas
        try { if (typeof solvedMap !== "undefined") { solvedMap = {}; saveSolvedToStorage(); } } catch (_) {}
        try {
          if (campaignState) {
            campaignState.roomSolvedTotals = {};
            campaignState.solvedAttribution = {};
            campaignState.lastLoadedCode = null;
            campaignState.lastLoadedRoomKey = null;
            campaignState.hint2Unlocked = false;
            campaignState.turnTokenUsed = false;
          }
        } catch (_) {}

        const { code, roomRef } = await hostCreateRoom(db2, { playersMax, puzzlesPerRoom, timeLimitSec, difficulty });
        const joinUrl = computeJoinUrl(code);

        showJoinSectionHost(code, joinUrl, playersMax);
        hostListenRoom(db2, code);
      });
    }
  }








// Listas de nombres que usaremos para repartir y para los selects
  const COMMANDMENTS = Object.keys(COMMANDMENT_META);
  const SINS = Object.keys(SIN_META);
  const musicToggleBtn = document.getElementById("musicToggleBtn");

	function showCampaignRolesSection() {
  transitionTo(() => {
      showView(rolesSection);
      if (sidebar) sidebar.style.display = "none";
  });
}


	  renderPlayersSummary();
	  updateContinueEnabled(); // lo que ya tengas aqu√≠
	

	function initCampaignPlayers(numPlayers) {
	  campaignState.roomSolvedCounts = Array.from({ length: numPlayers }, () => ({}));
	  campaignState.solvedPuzzlesByPlayer = Array.from({ length: numPlayers }, () => new Set());
	  campaignState.activePlayerIndex = 0;
	  campaignState.stage = "board";
	}

	function goToPuzzleFromCode(code) {
	  const parsed = parsePuzzleCode(code); // { roomKey:"origen", puzzleIndex:3 } etc.
	  if (!parsed) return;

	  campaignState.currentPuzzleCode = code;
	  campaignState.currentRoomKey = parsed.roomKey;
	  campaignState.stage = "puzzle";

	  loadRoom(parsed.roomKey, { forcePuzzleCode: code, fromCampaign: true });
	}

	function markCurrentPuzzleSolved() {
	  const p = campaignState.activePlayerIndex;
	  const code = campaignState.currentPuzzleCode;
	  const roomKey = campaignState.currentRoomKey;

	  if (!code || !roomKey) return;

	  // evitar doble conteo si ya lo resolvi√≥ ese jugador
	  if (campaignState.solvedPuzzlesByPlayer[p].has(code)) {
		// opcional: mostrar aviso ‚Äúya resuelto‚Äù
		return;
	  }

	  campaignState.solvedPuzzlesByPlayer[p].add(code);

	  const roomCounts = campaignState.roomSolvedCounts[p];
	  roomCounts[roomKey] = (roomCounts[roomKey] || 0) + 1;

	  // ¬øha completado la sala?
	  if (roomCounts[roomKey] >= campaignState.perRoomTarget) {
		campaignState.stage = "board";
		campaignState.currentPuzzleCode = null;
		campaignState.currentRoomKey = null;

		// IMPORTANTE: aqu√≠ vuelves al tablero
		showBoardScreen();
		  // Recompensa: fragmento del C√≥dice de la sala
		  showCodexReward(roomKey);
	  } else {
		// si no ha completado sala, puedes:
		// - volver al tablero igualmente (para meter siguiente c√≥digo)
		// - o dejarlo en salas
		// yo recomiendo volver al tablero siempre para ritmo de mesa
		campaignState.stage = "board";
		campaignState.currentPuzzleCode = null;
		campaignState.currentRoomKey = null;
		showBoardScreen();
	  }

	  renderCampaignSidebarStats(); // actualiza ‚ÄúResueltos: ‚Ä¶‚Äù
	}

	function nextPlayerTurn() {
	  const n = campaignState.solvedPuzzlesByPlayer.length;
	  campaignState.activePlayerIndex = (campaignState.activePlayerIndex + 1) % n;
	  renderCampaignSidebarStats();
	  renderTurnIndicator();
	}

	function openSinOverlayForPlayer(playerId) {
	  if (!campaignState) return;
	  sinSelectionPlayerId = playerId;

	  const player = campaignState.players.find(p => p.id === playerId);
	  if (!player) return;

	  sinOverlayTitle.textContent = `Elige un pecado para ${player.name}`;

	  const taken = new Set(
		campaignState.players
		  .filter(p => p.id !== playerId)
		  .map(p => p.sin)
		  .filter(Boolean)
	  );

	  sinCarousel.innerHTML = "";

	  Object.values(SIN_META).forEach(meta => {
		const takenByOther = taken.has(meta.key);

		const card = document.createElement("button");
		card.className = "sin-card";
		if (takenByOther) card.classList.add("sin-card--taken");
		if (player.sin === meta.key) card.classList.add("sin-card--selected");

		card.dataset.sin = meta.key;
		card.innerHTML = `
		  <img src="${meta.img}" alt="${meta.key}">
		  <div class="sin-card-title">${meta.key}</div>
		  <div class="sin-card-text">
			<strong>${meta.short}</strong><br>${meta.effect}
		  </div>
		`;

		sinCarousel.appendChild(card);
	  });

	  sinOverlay.classList.remove("sin-overlay--hidden");
	}

	function showCampaignBoardSection() {
  transitionTo(() => {
      showView(boardSection);
      setRitualOverlay("", false);
      if (sidebar) sidebar.style.display = "none";
  });
}

	

	function renderRolesScreen() {
	  rolesPlayersContainer.innerHTML = "";
	  campaignState.players.forEach((player, idx) => {
		const div = document.createElement("div");
		div.className = "player-role-card";
		div.innerHTML = `
		  <div class="player-role-header">Jugador ${idx + 1}</div>
		  <div class="effect-card">
			<img src="${player.mandamiento.img}" alt="${player.mandamiento.name}">
			<div class="effect-card-text">
			  <h4>Mandamiento: ${player.mandamiento.name}</h4>
			  <small>${player.mandamiento.tag}</small>
			  <p>${player.mandamiento.description}</p>
			  <p><strong>Efecto en el juego:</strong> ${player.mandamiento.effect}</p>
			</div>
		  </div>
		  <p style="margin-bottom:0.5rem;">Elige un pecado capital para este jugador:</p>
		  <div class="sins-grid" data-player="${idx}">
			${PECADOS.map(
			  s => `
			  <button class="sin-card" data-sin="${s.id}">
				<img src="${s.img}" alt="${s.name}">
				<div>
				  <strong>${s.name}</strong>
				  <small style="display:block;color:var(--muted);">${s.tag}</small>
				  <span style="font-size:0.8rem;display:block;">${s.effect}</span>
				</div>
			  </button>`
			).join("")}
		  </div>
		`;
		rolesPlayersContainer.appendChild(div);
	  });

	  // listeners para elegir pecados
	  rolesPlayersContainer.querySelectorAll(".sin-card").forEach(btn => {
		btn.addEventListener("click", () => {
		  const playerIdx = parseInt(
			btn.closest(".sins-grid").dataset.player,
			10
		  );
		  const sinId = btn.dataset.sin;
		  chooseSinForPlayer(playerIdx, sinId);
		  updateSinCardsUI();
		  updateContinueEnabled();
		});
	  });

	  updateSinCardsUI();
	  updateContinueEnabled();
	}

	function chooseSinForPlayer(playerIdx, sinId) {
	  // Un pecado no puede repetirse en dos jugadores
	  if (
		campaignState.players.some(
		  (p, i) => i !== playerIdx && p.pecado && p.pecado.id === sinId
		)
	  ) {
		alert("Ese pecado ya lo lleva otro jugador.");
		return;
	  }
	  const sin = SIN_META.find(s => s.id === sinId);
	  campaignState.players[playerIdx].pecado = sin;
	}

	function updateSinCardsUI() {
	  rolesPlayersContainer.querySelectorAll(".sins-grid").forEach((grid, idx) => {
		const chosen = campaignState.players[idx].pecado
		  ? campaignState.players[idx].pecado.id
		  : null;

		grid.querySelectorAll(".sin-card").forEach(btn => {
		  const id = btn.dataset.sin;
		  const takenByOther = campaignState.players.some(
			(p, i) => i !== idx && p.pecado && p.pecado.id === id
		  );
		  btn.classList.toggle("selected", id === chosen);
		  btn.classList.toggle("disabled", takenByOther);
		});
	  });
	}

	function updateContinueEnabled() {
	  if (!rolesToBoardBtn || !campaignState) return;
	  const allHaveSin = campaignState.players.every(p => p.pecado);
	  rolesToBoardBtn.disabled = !allHaveSin;
	}

  // --- PROGRESO ---

  function loadSolvedFromStorage() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      solvedMap = raw ? JSON.parse(raw) : {};
    } catch (e) {
      console.error("Error leyendo progreso:", e);
      solvedMap = {};
    }
  }

  function saveSolvedToStorage() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(solvedMap));
    } catch (e) {
      console.error("Error guardando progreso:", e);
    }
  }

  function isPuzzleSolved(id) {
    return !!(id && solvedMap[id]);
  }

  // --- CAMPa√±a: mandamientos y pecados ---

  function shuffle(array) {
    return array
      .map(v => ({ v, sort: Math.random() }))
      .sort((a, b) => a.sort - b.sort)
      .map(({ v }) => v);
  }

	function startCampaign(numPlayers) {
	  // baraja mandamientos
	  const shuffled = shuffle(Object.keys(COMMANDMENT_META));
	  const cmdKey = shuffled[i % shuffled.length];

	  const players = [];
	  for (let i = 0; i < numPlayers; i++) {
		const mand = shuffled[i % shuffled.length];
		players.push({
		  id: i + 1,
		  name: `Jugador ${i + 1}`,
		  mandamiento: mand,
		  pecado: null,
		  solved: 0
		});
	  }

	  campaignState = { players };

	  renderRolesScreen();
	  showCampaignRolesSection();
	}

	function renderPlayersSummary() {
  if (!playersSummaryEl || !campaignState) return;
  playersSummaryEl.innerHTML = "";

  const hideSecretsHost = (appMode === "host" && !!campaignState.hideSecretsOnHost);

  (campaignState.players || []).forEach(p => {
    const wrapper = document.createElement("section");
    wrapper.className = "player-panel";

    const isActive = (campaignState.activePlayerIndex === (p.id - 1));
    wrapper.style.outline = (campaignState.phase === "playing" && isActive) ? "2px solid var(--accent)" : "none";
    wrapper.style.borderRadius = "18px";

    const cmdInfo = (!hideSecretsHost && p.commandment) ? (COMMANDMENT_META[p.commandment] || null) : null;
    const cmdName = hideSecretsHost ? "Secreto" : (p.commandment || "‚Äî");
    const cmdImgHtml = cmdInfo ? `<img src="${cmdInfo.image}" alt="${cmdName}">` : "";
    const cmdDesc = cmdInfo
      ? (cmdInfo.blessing || cmdInfo.short || "")
      : (hideSecretsHost ? "Oculto para el host." : "Bendici√≥n especial para este jugador.");

    const sinInfo = (!hideSecretsHost && p.sin) ? (SIN_META[p.sin] || null) : null;

    let sinTitle = "Sin elegir";
    let sinBodyHtml = "";

    if (hideSecretsHost) {
      sinTitle = "Secreto";
      // En modo host-multijugador, el pecado vive en Firestore (hostPlayers), no en campaignState.players.
      const hp = (multiplayer && multiplayer.hostPlayers ? multiplayer.hostPlayers : []).find(h => (h.seatNumber || 0) === (p.id || 0));
      const hasSin = !!(hp && hp.sinKey);
      sinBodyHtml = `<p class="role-card-desc">
        ${hasSin ? "Elegido en el m√≥vil (oculto)." : "Pendiente de elegir en el m√≥vil."}
      </p>`;
    } else if (sinInfo) {
      sinTitle = sinInfo.key;
      sinBodyHtml = `<div class="role-card-body">
        <img src="${sinInfo.img}" alt="${sinInfo.key}">
        <p class="role-card-desc"><strong>${sinInfo.short}</strong><br>${sinInfo.effect}</p>
      </div>`;
    } else {
      sinTitle = "Sin elegir";
      sinBodyHtml = `<p class="role-card-desc">
        Elige un pecado para este jugador. Cada uno modifica su forma de jugar.
      </p>
      <button class="action secondary btn-open-sin-picker" data-player-id="${p.id}">
        Elegir pecado
      </button>`;
    }

    wrapper.innerHTML = `
      <div class="player-panel-title">${p.name || ("Jugador " + p.id)}</div>

      <div class="player-panel-roles">
        <article class="role-card role-card--cmd">
          <header>
            <div class="role-card-label">Mandamiento</div>
            <div class="role-card-name">${cmdName}</div>
          </header>
          <div class="role-card-body">
            ${cmdImgHtml}
            <p class="role-card-desc">${cmdDesc}</p>
          </div>
        </article>

        <article class="role-card role-card--sin">
          <header>
            <div class="role-card-label">Pecado capital</div>
            <div class="role-card-name">${sinTitle}</div>
          </header>
          ${sinBodyHtml}
        </article>
      </div>

      <div class="player-panel-footer">
        <span>Acertijos resueltos: ${p.solved || 0}</span>
      </div>
    `;

    playersSummaryEl.appendChild(wrapper);
  });

  // En multijugador (secretismo), el tablero no debe depender de si el host conoce los pecados.
  const shouldHideBoard = (!campaignState.hideSecretsOnHost) && (campaignState.phase === "sin-picking");
  if (boardMain) boardMain.style.display = shouldHideBoard ? "none" : "";
  if (boardControls) boardControls.style.display = shouldHideBoard ? "none" : "";
}




  // --- AUXILIARES DE UI ---

  function setActiveRoomButton(key) {
    roomButtons.forEach(btn => {
      btn.classList.toggle("active", key && btn.dataset.room === key);
    });
  }

	function playBackgroundMusic() {
  if (appMode === "player") return; // sin m√∫sica en pantallas individuales

  // En modo salas (Explorar / Campa√±a) NUNCA suena la m√∫sica general
  const inRoomView = (typeof roomSection !== "undefined" && roomSection && roomSection.style.display !== "none");
  if (inRoomView || gameMode === "free" || gameMode === "campaign-room") return;

	  if (!bgAudioEl || bgMusicMuted) return; // ‚¨Ö respeta el mute
	  try {
		bgAudioEl.volume = 0.4; // ajusta si quieres
		const p = bgAudioEl.play();
		if (p && p.catch) {
		  p.catch(() => {
			// El navegador puede bloquear el autoplay, no pasa nada.
		  });
		}
	  } catch (e) {
		console.warn("No se pudo reproducir la m√∫sica de fondo", e);
	  }
	}

	function playRoomMusic() {
	  if (!roomAudioEl || roomMusicMuted) return;
	  try {
		const p = roomAudioEl.play();
		if (p && p.catch) {
		  p.catch(() => {
			// por si el navegador bloquea el autoplay
		  });
		}
	  } catch (e) {
		console.warn("No se pudo reproducir la m√∫sica de la sala", e);
	  }
	}

	function stopBackgroundMusic() {
	  if (!bgAudioEl) return;
	  bgAudioEl.pause();
	  // Si NO quieres que vuelva al principio cada vez, comenta la siguiente l√≠nea:
	  // bgAudioEl.currentTime = 0;
	}

  function stopAudio() {
    if (roomAudioEl) roomAudioEl.pause();
  }

  // Mantiene la m√∫sica coherente al volver a la pesta√±a/ventana (evita que reaparezca la m√∫sica general en salas)
  function syncAudioForCurrentView() {
    if (appMode === "player") return;

    const inRoomView = (roomSection && roomSection.style.display !== "none") || gameMode === "free" || gameMode === "campaign-room";
    if (inRoomView) {
      stopBackgroundMusic();
      playRoomMusic(); // respeta roomMusicMuted
    } else {
      // Fuera de salas: solo m√∫sica general
      if (roomAudioEl) roomAudioEl.pause();
      playBackgroundMusic(); // ya respeta bgMusicMuted
    }
  }

  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) syncAudioForCurrentView();
  });
  window.addEventListener("focus", syncAudioForCurrentView);


  function getRoomSolvedCounts(roomKey) {
    const room = rooms[roomKey];
    if (!room || !room.puzzles) return { solved: 0, total: 0 };
    let solved = 0;
    const total = room.puzzles.length;
    room.puzzles.forEach(p => {
      if (p.id && isPuzzleSolved(p.id)) solved++;
    });
    return { solved, total };
  }

  function updateSidebarRoomCounters() {
    Object.keys(rooms).forEach(key => {
      const { solved, total } = getRoomSolvedCounts(key);
      const span = document.querySelector(`[data-room-counter="${key}"]`);
      if (span) span.textContent = `${solved}/${total}`;
    });
  }

  function updateRoomSolvedSummary() {
    if (!roomSolvedSummaryEl || !currentRoomKey) return;
    const { solved, total } = getRoomSolvedCounts(currentRoomKey);
    roomSolvedSummaryEl.textContent =
      `Resueltos en esta sala: ${solved} de ${total}`;
  }

  function getGlobalSolvedCounts() {
    let solved = 0;
    let total = 0;
    Object.values(rooms).forEach(room => {
      const puzzles = room.puzzles || [];
      total += puzzles.length;
      puzzles.forEach(p => {
        if (p.id && isPuzzleSolved(p.id)) solved++;
      });
    });
    return { solved, total };
  }

  function updateGlobalSolvedSummary() {
    if (!globalSolvedSummaryEl) return;
    const { solved, total } = getGlobalSolvedCounts();
    globalSolvedSummaryEl.textContent =
      `Total: ${solved} acertijo(s) resuelto(s) de ${total}`;
  }

  function updateSolvedUIForCurrentPuzzle() {
    const room = rooms[currentRoomKey];
    const puzzles = room ? room.puzzles : null;
    const puzzle = (puzzles && puzzles.length > 0)
      ? puzzles[currentPuzzleIndex]
      : null;
    const solved = puzzle && puzzle.id && isPuzzleSolved(puzzle.id);

    if (puzzleCardEl) {
      puzzleCardEl.classList.toggle("puzzle-solved", !!solved);
      puzzleCardEl.classList.toggle("solved", !!solved);
    }

    if (toggleSolvedBtn) {
      const hasPuzzle = !!(puzzle && puzzle.id);
      toggleSolvedBtn.disabled = !hasPuzzle;
      toggleSolvedBtn.classList.toggle("solved", !!solved);
      toggleSolvedBtn.textContent = solved
        ? "Marcar como NO resuelto"
        : "Marcar como resuelto";
    }

    if (puzzleStateEl) {
      if (!puzzle) puzzleStateEl.textContent = "Sin acertijos";
      else puzzleStateEl.textContent = solved ? "Resuelto" : "Sin resolver";
    }
  }

	function stopCampaignTimer() {
	  if (!campaignState) return;
	  if (campaignState.timerIntervalId) {
		clearInterval(campaignState.timerIntervalId);
		campaignState.timerIntervalId = null;
	  }
	}

	
	
  
async function hostHandleAction(db, a) {
    if (!multiplayer.roomRef || appMode === "player") return;
    if (!campaignState) return; // permitir en tablero y en sala

    const room = multiplayer.latestRoom || {};
    const activeSeat = room.activeSeatNumber || null;
    const puzzleCode = room.currentPuzzleCode || null;
    const tokenUsed = !!room.turnTokenUsed;

    if (!puzzleCode) return; // no hay acertijo activo
    if (!activeSeat || !a.seatNumber || a.seatNumber !== activeSeat) return; // solo jugador activo
    if (tokenUsed || campaignState.turnTokenUsed) return;
    if ((room.turnCounter || 0) !== (a.turnCounter || 0)) return; // acci√≥n de turno viejo

    const getSeatRoles = (seat) => {
      // En host, la fuente fiable de roles es hostPlayers (no playerList).
      const list = (multiplayer && Array.isArray(multiplayer.hostPlayers) && multiplayer.hostPlayers.length)
        ? multiplayer.hostPlayers
        : (multiplayer.playerList || []);
      const p = list.find(x => Number(x.seatNumber) === Number(seat)) || {};
      return {
        cmdKey: p.commandmentKey || p.commandment || p.mandamiento || null,
        sinKey: p.sinKey || p.sin || p.pecado || null
      };
    };
    const roles = getSeatRoles(activeSeat);
    const activeCmdKey = roles.cmdKey;
    const activeSinKey = roles.sinKey;

    if (a.type === "HINT2_UNLOCK") {
      // Restricciones / votos
      if (campaignState.hint2HardLocked) {
        setCampaignStatus("‚õî Pista 2 est√° bloqueada este turno.");
        return;
      }
      if (activeCmdKey === "No tendr√°s otros dioses" && (campaignState.timerRemaining || 0) > 120) {
        setCampaignStatus("‚õìÔ∏è Voto (M1): Pista 2 bloqueada hasta que el reloj baje de 120s.");
        return;
      }
      if (activeCmdKey === "No robar√°s") {
        const lastMap = room.lastUsedHint2BySeat || {};
        if (lastMap[String(activeSeat)]) {
          setCampaignStatus("‚õìÔ∏è Voto (M7): no puedes usar Pista 2 dos turnos seguidos.");
          return;
        }
      }

      campaignState.hint2Unlocked = true;

      // Coste P2 (Avaricia): si desbloqueas Pista 2, -15s
      if (activeSinKey === "Avaricia") {
        campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) - 15);
        updateTimerUI();
      }

      campaignState.turnTokenUsed = true;
      if (campaignState.turnFlags) campaignState.turnFlags.usedHint2Unlock = true;

      /* (silenciado) */
      if (gameMode === "campaign-room") {
        refreshHintButtonsUI(rooms[currentRoomKey]?.puzzles?.[currentPuzzleIndex] || null);
      }

      const map = Object.assign({}, room.lastUsedHint2BySeat || {});
      map[String(activeSeat)] = true;

      await multiplayer.roomRef.update({
        hint2Unlocked: true,
        turnTokenUsed: true,
        lastTokenType: "hint2",
        lastUsedHint2BySeat: map
      });
      return;
    }

    if (a.type === "POWER") {
      if (a.role === "commandment") {
        const key = a.key;
        const meta = key ? COMMANDMENT_META[key] : null;
        if (!meta || !meta.power) return;

        // Votos que bloquean Milagro
        if (key === "Honrar√°s a tu padre y madre" && campaignState.hint2Unlocked) {
          setCampaignStatus("‚õìÔ∏è Voto (M4): no puedes usar Milagro si ya desbloqueaste Pista 2.");
          return;
        }
        if (key === "No matar√°s" && (campaignState.attemptsRemaining || 0) <= 1) {
          setCampaignStatus("‚õìÔ∏è Voto (M5): con 1 intento no puedes gastar s√≠mbolo en poderes.");
          return;
        }
        if (key === "No codiciar√°s bienes ajenos" && campaignState.turnFlags && !campaignState.turnFlags.spentAttempt && !(campaignState.turnFlags.hasVerified)) {
          setCampaignStatus("‚õìÔ∏è Voto (M9): primero debes intentar (verificar o gastar 1 intento).");
          return;
        }

        // L√≠mite de uso por partida
        if (meta.power.uses && meta.power.uses.per === "game") {
          const used = (room.usedMiraclesGame && room.usedMiraclesGame[String(activeSeat)] && room.usedMiraclesGame[String(activeSeat)][key]) ? true : false;
          if (used) {
            setCampaignStatus("‚õî Ya has usado este Milagro en la partida.");
            return;
          }
        }

        // Consumir s√≠mbolo
        campaignState.turnTokenUsed = true;
        if (campaignState.turnFlags) campaignState.turnFlags.usedPower = true;

        // Guardar uso si es 1/partida
        let updatePayload = { turnTokenUsed: true, lastTokenType: "power" };
        if (meta.power.uses && meta.power.uses.per === "game") {
          const usedAll = Object.assign({}, room.usedMiraclesGame || {});
          const usedSeat = Object.assign({}, usedAll[String(activeSeat)] || {});
          usedSeat[key] = true;
          usedAll[String(activeSeat)] = usedSeat;
          updatePayload.usedMiraclesGame = usedAll;
        }
        await multiplayer.roomRef.update(updatePayload);

        const eff = meta.power.effect || {};

        // Efectos de Milagro
        if (eff.addTimeSec) {
          campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) + eff.addTimeSec);
          updateTimerUI();
        }
        if (eff.addAttempts) {
          const cap = (eff.maxAttempts != null) ? eff.maxAttempts : (eff.capAttempts != null ? eff.capAttempts : null);
          let next = Math.max(0, (campaignState.attemptsRemaining || 0) + eff.addAttempts);
          if (cap != null) next = Math.min(cap, next);
          campaignState.attemptsRemaining = next;
          updateAttemptsUI();
        }
        if (eff.freezeTimeSec) {
          campaignState.freezeUntilTs = Date.now() + (eff.freezeTimeSec * 1000);
        }
        if (eff.restoreAttemptOnWrongOnce) {
          campaignState.restoreAttemptOnWrongOnce = true;
        }
        if (eff.setTimeToSecIfBelow != null) {
          const thr = eff.thresholdBelowSec != null ? eff.thresholdBelowSec : 0;
          if ((campaignState.timerRemaining || 0) < thr) {
            campaignState.timerRemaining = eff.setTimeToSecIfBelow;
            updateTimerUI();
          }
        }
        if (eff.revealKeyword) {
          const pz = getCurrentPuzzleSafe();
          const kw = pz && pz.keyword ? pz.keyword : null;
          setCampaignStatus(kw ? `üîé Palabra clave: ${kw}` : "üîé Palabra clave no disponible en este acertijo.");
        }
        if (eff.clearActivePenaltyOnce) {
          const snap = campaignState.appliedPenaltySnapshot;
          if (snap) {
            if (snap.timeDelta) campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) - snap.timeDelta);
            if (snap.attemptsDelta) campaignState.attemptsRemaining = Math.max(0, (campaignState.attemptsRemaining || 0) - snap.attemptsDelta);
            campaignState.hint2HardLocked = false;
            campaignState.verifyLockedWhileRemainingAbove = null;
            campaignState.wrongPenaltyOverrideSec = null;
            campaignState.wrongExtraAttemptLoss = false;
            campaignState.activePhysicalPenaltyText = null;
            campaignState.appliedPenaltySnapshot = null;
            updateTimerUI();
            updateAttemptsUI();
          }
        }
        if (eff.unlockHint2) {
          campaignState.hint2Unlocked = true;
          if (gameMode === "campaign-room") {
        refreshHintButtonsUI(rooms[currentRoomKey]?.puzzles?.[currentPuzzleIndex] || null);
      }
          await multiplayer.roomRef.update({ hint2Unlocked: true });
        }
        if (eff.warmerColderOnce) {
          const pz = getCurrentPuzzleSafe();
          const ans = (pz && pz.answer) ? pz.answer : null;
          const last = campaignState.lastEnteredAnswerNorm;
          if (!ans || last == null) {
            setCampaignStatus("‚öñÔ∏è Veredicto: necesitas al menos una respuesta previa y una respuesta num√©rica para comparar.");
          } else {
            const truth = normalizeNumeric(ans);
            const lastNum = normalizeNumeric(last);
            const curRaw = answerInput ? answerInput.value : "";
            const curNum = normalizeNumeric(curRaw);
            if (!truth || !lastNum || !curNum) {
              setCampaignStatus("‚öñÔ∏è Veredicto: solo funciona con respuestas num√©ricas.");
            } else {
              const dLast = Math.abs(parseFloat(truth) - parseFloat(lastNum));
              const dCur = Math.abs(parseFloat(truth) - parseFloat(curNum));
              setCampaignStatus(dCur < dLast ? "‚öñÔ∏è Veredicto: M√ÅS CERCA." : (dCur > dLast ? "‚öñÔ∏è Veredicto: M√ÅS LEJOS." : "‚öñÔ∏è Veredicto: IGUAL."));
            }
          }
        }

        return;
      }

      if (a.role === "sin") {
        const key = a.key;
        const meta = key ? SIN_META[key] : null;
        const pen = meta && meta.temptation && meta.temptation.targetPenalty ? meta.temptation.targetPenalty : null;
        const targetSeat = a.targetSeat;
        if (!targetSeat || !pen) return;

        // Consumir s√≠mbolo
        campaignState.turnTokenUsed = true;
        if (campaignState.turnFlags) campaignState.turnFlags.usedPower = true;
        await multiplayer.roomRef.update({ turnTokenUsed: true, lastTokenType: "power" });

        // Guardar penalizaci√≥n para el siguiente acertijo del objetivo
        await db.runTransaction(async (tx) => {
          const snap = await tx.get(multiplayer.roomRef);
          if (!snap.exists) return;
          const r = snap.data() || {};
          const pending = Object.assign({}, r.pendingPenalties || {});
          const cur = Object.assign({}, pending[String(targetSeat)] || {});
          pending[String(targetSeat)] = Object.assign(cur, pen, { sinKey: key });
          tx.update(multiplayer.roomRef, { pendingPenalties: pending });
        });

        /* (silenciado) */
        return;
      }
    }
  }
function updateAttemptsUI() {
	  const el = document.getElementById("campaignAttempts");
	  if (!el || !campaignState) return;
	  el.textContent = String(Math.max(0, campaignState.attemptsRemaining ?? 0));
	}

	function setCampaignStatus(msg) {
	  const el = document.getElementById("campaignStatus");
	  if (!el) return;
	  el.textContent = msg || "";
	}

	function isHint2Locked() {
	  return (gameMode === "campaign-room" && campaignState && (!campaignState.hint2Unlocked || !!campaignState.hint2HardLocked));
	}

	function refreshHintButtonsUI(puzzle) {
	  const hint1Btn = document.getElementById("hint1Btn");
	  const hint2Btn = document.getElementById("hint2Btn");
	  if (hint1Btn) {
	    const locked1 = (gameMode === "campaign-room" && campaignState && campaignState.blockHint1Until && Date.now() < campaignState.blockHint1Until);
	    hint1Btn.textContent = locked1 ? "Pista 1 üîí" : "Pista 1";
	  }
	  if (hint2Btn) {
	    const locked2 = !!(puzzle && puzzle.hint2) && isHint2Locked();
	    hint2Btn.textContent = locked2 ? "Pista 2 üîí" : "Pista 2";
	  }
	}
function updateTimerUI() {
	  const el = document.getElementById("campaignTimer");
	  if (!el || !campaignState) return;

	  const s = Math.max(0, campaignState.timerRemaining);
	  const mm = String(Math.floor(s / 60)).padStart(2, "0");
	  const ss = String(s % 60).padStart(2, "0");
	  el.textContent = `${mm}:${ss}`;
	}

	function startCampaignTimer() {
	  if (!campaignState) return;

	  stopCampaignTimer();
	  if (!campaignState.timerEnabled) return;

	  updateTimerUI();
	  campaignState.timerIntervalId = setInterval(() => {
        // Congelaci√≥n temporal (Mandamiento II)
        const now = Date.now();
        if (campaignState.freezeUntilTs && now < campaignState.freezeUntilTs) {
          updateTimerUI();
          return;
        }

        campaignState.timerRemaining -= 1;
        updateTimerUI();

        // Voto M6: si desbloqueas Pista 2, debes verificar antes de 60s restantes
        if (campaignState.activeCmdKey === "No cometer√°s adulterio" &&
            campaignState.hint2Unlocked &&
            !(campaignState.turnFlags && campaignState.turnFlags.hasVerified) &&
            campaignState.timerRemaining <= 60) {
          stopCampaignTimer();
          setCampaignStatus("‚õìÔ∏è Voto incumplido (M6): no verificaste antes de 60s. Pierdes el turno.");
          failOrSkipCurrentPuzzle("vow_m6");
          return;
        }

        if (campaignState.timerRemaining <= 0) {
          stopCampaignTimer();
          failOrSkipCurrentPuzzle("timeout"); // se acab√≥ el tiempo
        }
      }, 1000);}

	
function advanceTurnCampaign() {
      if (!campaignState) return;

      // asiento del jugador que TERMINA el turno (antes de avanzar)
      const prevSeat = (campaignState.players && campaignState.players[campaignState.activePlayerIndex])
        ? campaignState.players[campaignState.activePlayerIndex].id
        : (campaignState.activePlayerIndex + 1);

      // Avanzar jugador activo
      campaignState.activePlayerIndex = (campaignState.activePlayerIndex + 1) % campaignState.players.length;

      // asiento del jugador que EMPIEZA
      const nextSeat = (campaignState.players && campaignState.players[campaignState.activePlayerIndex])
        ? campaignState.players[campaignState.activePlayerIndex].id
        : (campaignState.activePlayerIndex + 1);

      // Actualizar mapa ‚Äúus√≥ Pista 2 en su turno anterior‚Äù (para voto M7)
      const room = multiplayer.latestRoom || {};
      const map = Object.assign({}, room.lastUsedHint2BySeat || {});
      map[String(prevSeat)] = !!(campaignState.turnFlags && campaignState.turnFlags.usedHint2Unlock);

      // Publicar turno en Firestore (host)
      if (multiplayer.roomRef && appMode !== "player") {
        multiplayer.roomRef.update({
          activeSeatNumber: nextSeat,
          turnTokenUsed: false,
          hint2Unlocked: false,
          currentPuzzleCode: null,
          currentRoomKey: null,
          lastUsedHint2BySeat: map,
          turnCounter: firebase.firestore.FieldValue.increment(1)
        }).catch(()=>{});
      }
    }


	function failOrSkipCurrentPuzzle(reason = "skip") {
	  if (!campaignState) return;

	  // No sumamos nada. S√≥lo limpiamos el puzzle actual y volvemos al tablero.
	  stopCampaignTimer();
	  campaignState.currentPuzzleCode = null;
	  campaignState.currentRoomKey = null;
	  if (multiplayer.roomRef && appMode !== "player") {
		multiplayer.roomRef.update({ currentPuzzleCode: null, currentRoomKey: null, hint2Unlocked: false, turnTokenUsed: false }).catch(()=>{});
	  }
	  campaignState.timerRemaining = campaignState.timeLimitSec;
      // Reset UI de respuesta
      if (answerInput) answerInput.value = "";
      setAnswerFeedback("", null);


	  campaignState.attemptsRemaining = campaignState.attemptsMax || 2;
	  campaignState.hint2Unlocked = false;
	  campaignState.turnTokenUsed = false;
	  updateAttemptsUI();
	  refreshHintButtonsUI(null);

	  // Pasa turno
	  advanceTurnCampaign();

	  // Volver al tablero (funci√≥n real que s√≠ tienes)
	  showBoard();
	  renderPlayersSummary();
	}

	function toggleSolvedCurrentPuzzle() {
	  const room = rooms[currentRoomKey];
	  stopCampaignTimer();
	  if (!room || !room.puzzles || room.puzzles.length === 0) return;

	  const puzzle = room.puzzles[currentPuzzleIndex];
	  if (!puzzle || !puzzle.id) return;

	  const id = puzzle.id.toUpperCase();
	  const wasSolved = !!solvedMap[id];

	  // 1) Toggle en el progreso global
	  if (wasSolved) delete solvedMap[id];
	  else solvedMap[id] = true;

	  saveSolvedToStorage();

	  // 2) ‚úÖ Si estamos en campa√±a, y lo ACABAMOS de marcar como resuelto:
	  if (gameMode === "campaign-room" && campaignState && !wasSolved) {
		const pIdx = campaignState.activePlayerIndex;

		// Atribuci√≥n (evita doble conteo si alguien vuelve a marcar lo mismo)
		if (campaignState.solvedAttribution[id] == null) {
		  campaignState.solvedAttribution[id] = pIdx;

		  // contador jugador
		  campaignState.players[pIdx].solved = (campaignState.players[pIdx].solved || 0) + 1;

		  // contador sala (global del grupo)
		  const rk = campaignState.lastLoadedRoomKey || currentRoomKey;
		  campaignState.roomSolvedTotals[rk] = (campaignState.roomSolvedTotals[rk] || 0) + 1;

		  // ¬øsala completada?
		  const target = campaignState.puzzlesPerRoom || 3;
		  const done = campaignState.roomSolvedTotals[rk] >= target;

		  // 3) ‚úÖ Volver al tablero s√≠ o s√≠
		  showBoard();

		  // 4) ‚úÖ Pasar turno autom√°tico (opcional)
		  // IMPORTANT√çSIMO: en multijugador, el turno REAL vive en Firestore.
		  if (campaignState.autoPassTurn) {
			advanceTurnCampaign(); // publica activeSeatNumber + resetea token/pistas en Firestore
		  }
// Actualiza el panel
		  renderPlayersSummary();

		  // üéÅ Recompensa visual por sala (solo host)
		  if (done) {
			window.showCodexReward && window.showCodexReward(rk);
		  }
		} else {
		  // Ya estaba atribuido: igualmente vuelve al tablero para ritmo
		  showBoard();
		  renderPlayersSummary();
		}

		// Importante: no sigas, porque ya hemos navegado al tablero
		return;
	  }

	  // UI est√°ndar (modo libre o desmarcar)
	  updateSolvedUIForCurrentPuzzle();
	  updateSidebarRoomCounters();
	  updateRoomSolvedSummary();
	  updateGlobalSolvedSummary();
	}


  // --- CAMBIO DE PANTALLA ---

	function showHome() {
  transitionTo(() => {
      gameMode = "home";
      stopCampaignTimer();
      showView(homeSection);
      if (appRoot) appRoot.classList.add("home-mode");
      if (sidebar) sidebar.style.display = "none";
      
      stopAudio();
      playBackgroundMusic();
      
      if (globalMusicToggleContainer) globalMusicToggleContainer.style.display = "flex";
      if (roomMusicToggleContainer) roomMusicToggleContainer.style.display = "none";
      
      setActiveRoomButton(null);

      // ‚úÖ (Host) Al volver al tablero, indicar que no hay acertijo activo.
      if (multiplayer.roomRef && appMode !== "player") {
        multiplayer.publishedPuzzleCode = null;
        multiplayer.roomRef.update({
          currentPuzzleCode: null,
          currentRoomKey: null,
          hint2Unlocked: false,
          turnTokenUsed: false
        }).catch(()=>{});
      }
      if (appRoot) requestAnimationFrame(() => appRoot.classList.remove("booting"));
  });
}



	function showCampaignSetup() {
  transitionTo(() => {
      gameMode = "campaign-setup";
      showView(campaignSetupSection);
      if (appRoot) appRoot.classList.remove("home-mode");
      if (sidebar) sidebar.style.display = "none";
      
      stopAudio();
      playBackgroundMusic();
      
      if (globalMusicToggleContainer) globalMusicToggleContainer.style.display = "flex";
      if (roomMusicToggleContainer) roomMusicToggleContainer.style.display = "none";
      setActiveRoomButton(null);
  });
}


	function showBoard() {
  transitionTo(() => {
      gameMode = "campaign-board";
      stopCampaignTimer();
      showView(boardSection);
      setRitualOverlay("", false);
      if (sidebar) sidebar.style.display = "none";
      
      stopAudio();
      playBackgroundMusic();
      if (globalMusicToggleContainer) globalMusicToggleContainer.style.display = "flex";
      if (roomMusicToggleContainer) roomMusicToggleContainer.style.display = "none";
      setActiveRoomButton(null);
  });
}


  function showRules() {
  transitionTo(() => {
      gameMode = "rules";
      showView(rulesSection);
      if (appRoot) appRoot.classList.add("home-mode");
      if (sidebar) sidebar.style.display = "none";
      
      stopAudio();
      playBackgroundMusic();
      if (globalMusicToggleContainer) globalMusicToggleContainer.style.display = "flex";
      if (roomMusicToggleContainer) roomMusicToggleContainer.style.display = "none";
      setActiveRoomButton(null);
  });
}


	function showRoomSectionImmediate() {
      // OJO: no cambiamos gameMode aqu√≠. Quien navega decide si es "free" o "campaign-room".
      showView(roomSection);

      const inCampaignRoom = (gameMode === "campaign-room");

      // Sidebar (men√∫ de salas) solo en modo libre
      if (sidebar) sidebar.style.display = inCampaignRoom ? "none" : "block";

      // En campa√±a no se permite navegar por libre entre acertijos/salas
      const puzzleJump = document.querySelector(".puzzle-jump");
      if (puzzleJump) puzzleJump.style.display = inCampaignRoom ? "none" : "flex";
      if (prevBtn) prevBtn.style.display = inCampaignRoom ? "none" : "";
      if (nextBtn) nextBtn.style.display = inCampaignRoom ? "none" : "";

      // M√∫sica: en salas suena la m√∫sica de sala (y se corta la general)
      stopBackgroundMusic();
      playRoomMusic(); // respeta roomMusicMuted

      // Controles: en sala solo bot√≥n de sala
      if (globalMusicToggleContainer) globalMusicToggleContainer.style.display = "none";
      if (roomMusicToggleContainer) roomMusicToggleContainer.style.display = "flex";

      // Resaltado de la sala actual solo en modo libre
      if (!inCampaignRoom) setActiveRoomButton(currentRoomKey);
      else setActiveRoomButton(null);

      // Texto del bot√≥n seg√∫n estado
      if (roomMusicToggleBtn) {
        roomMusicToggleBtn.textContent = roomMusicMuted
          ? "üîá M√∫sica de la sala: OFF"
          : "üîä M√∫sica de la sala: ON";
      }
}

function showRoomSection() {
  transitionTo(() => {
    showRoomSectionImmediate();
  });
}




  // --- Carga de acertijos/salas ---

  function loadPuzzle() {
    const room = rooms[currentRoomKey];
    const puzzles = room ? room.puzzles : null;

    if (!room || !puzzles || puzzles.length === 0) {
      if (puzzleIdEl) puzzleIdEl.textContent = "--";
      if (puzzleDifficultyEl) puzzleDifficultyEl.textContent = "Sin acertijos a√∫n";
      if (puzzleTitleEl) puzzleTitleEl.textContent = "Sin acertijos definidos en esta sala";
      if (puzzleBodyEl) {
        puzzleBodyEl.textContent =
          "Todav√≠a no has a√±adido acertijos a esta sala. √ösala como campa√±a futura o en construcci√≥n.";
      }
      if (puzzleTagsEl) puzzleTagsEl.textContent = "";
      if (bibleBadgeEl) bibleBadgeEl.style.display = "none";

      [hint1El, hint2El, solutionEl].forEach(el => {
        if (el) {
          el.classList.remove("visible");
          el.textContent = "";
        }
      });

      if (hint1Btn) hint1Btn.disabled = true;
      if (hint2Btn) hint2Btn.disabled = true;
      if (solutionBtn) solutionBtn.disabled = true;
      if (prevBtn) prevBtn.disabled = true;
      if (nextBtn) nextBtn.disabled = true;

      if (puzzleCounterEl) puzzleCounterEl.textContent = "0 acertijos";
      // Reset UI de respuesta (vac√≠o)
      if (answerInput) answerInput.value = "";
      setAnswerFeedback("", null);

      if (progressFillEl) progressFillEl.style.width = "0%";

		updateSolvedUIForCurrentPuzzle();

		// ‚úÖ Timer de campa√±a: reset y start al cargar un acertijo (solo en campa√±a)
		if (gameMode === "campaign-room" && campaignState && campaignState.timerEnabled) {
		  campaignState.timerRemaining = campaignState.timeLimitSec; // reset
		  startCampaignTimer();
		} else {
		  stopCampaignTimer();
		}
	  
      return;
    }

    if (currentPuzzleIndex < 0) currentPuzzleIndex = 0;
    if (currentPuzzleIndex >= puzzles.length) currentPuzzleIndex = 0;

    const puzzle = puzzles[currentPuzzleIndex];

    // ‚úÖ (Host) Publicar acertijo activo en Firestore para que los m√≥viles sepan que hay turno en curso.
    // Solo cuando cambia de acertijo (evita resetear el estado si el host re-renderiza la UI).
    if (gameMode === "campaign-room" && multiplayer.roomRef && appMode !== "player") {
      const newCode = (puzzle && puzzle.id) ? puzzle.id : null;
      if (newCode && multiplayer.publishedPuzzleCode !== newCode) {
        multiplayer.publishedPuzzleCode = newCode;
        multiplayer.roomRef.update({
          currentPuzzleCode: newCode,
          currentRoomKey: currentRoomKey,
          hint2Unlocked: false,
          turnTokenUsed: false
        }).catch(()=>{});
      }
    }


    if (puzzleIdEl) puzzleIdEl.textContent = puzzle.id || "--";
    if (puzzleDifficultyEl) puzzleDifficultyEl.textContent = puzzle.difficulty || "";
    if (puzzleTitleEl) puzzleTitleEl.textContent = puzzle.title || "";
    if (puzzleBodyEl) puzzleBodyEl.textContent = puzzle.body || "";
    if (puzzleTagsEl) puzzleTagsEl.textContent = puzzle.tags || "";
    if (bibleBadgeEl) {
      bibleBadgeEl.style.display = puzzle.requiresBible ? "inline-flex" : "none";
    }

    const position = currentPuzzleIndex + 1;
    const total = puzzles.length;
    if (puzzleCounterEl) {
      puzzleCounterEl.textContent = `Acertijo ${position} de ${total}`;
    }
    if (progressFillEl) {
      const progressPercent = (position / total) * 100;
      progressFillEl.style.width = progressPercent + "%";
    }

    if (hint1El) {
      hint1El.classList.remove("visible");
      hint1El.textContent = puzzle.hint1 || "Sin pista definida.";
    }
    if (hint2El) {
      hint2El.classList.remove("visible");
      hint2El.textContent = puzzle.hint2 || "Sin segunda pista definida.";
    }
    if (solutionEl) {
      solutionEl.classList.remove("visible");
      solutionEl.textContent = puzzle.solution || "Sin soluci√≥n registrada.";
    }

    if (hint1Btn) hint1Btn.disabled = !puzzle.hint1;
    if (hint2Btn) hint2Btn.disabled = !puzzle.hint2;
    if (solutionBtn) solutionBtn.disabled = !puzzle.solution;

    // --- Campa√±a: reset de intentos + bloqueo Pista 2 por s√≠mbolo ---
    if (gameMode === "campaign-room" && campaignState) {
      // defaults
      campaignState.timeLimitSec = (multiplayer && multiplayer.latestRoom && multiplayer.latestRoom.timeLimitSec)
        ? (multiplayer.latestRoom.timeLimitSec || 180)
        : (campaignState.timeLimitSec || 180);
      campaignState.attemptsMax = 2;
      campaignState.attemptsRemaining = 2;
      campaignState.hint2Unlocked = false;
      campaignState.turnTokenUsed = false;
      campaignState.ignoreNextTimePenaltyOnce = false;
      campaignState.blockHint1Until = 0;
      campaignState.hint2HardLocked = false;
      campaignState.turnFlags = { verifyCount: 0, hasVerified: false, spentAttempt: false, openedHint1: false, usedHint2Unlock: false, usedPower: false, firstWrongNoTimePenaltyUsed: false };
      campaignState.wrongPenaltyOverrideSec = null;
      campaignState.wrongExtraAttemptLoss = false;
      campaignState.verifyLockedWhileRemainingAbove = null;
      campaignState.activePhysicalPenaltyText = null;
      campaignState.appliedPenaltySnapshot = null;
      campaignState.freezeUntilTs = 0;
      campaignState.restoreAttemptOnWrongOnce = false;
      campaignState.warmerColderAvailable = false;
      campaignState.lastEnteredAnswerNorm = null;


      // Reset timer y arrancar
      campaignState.timerRemaining = campaignState.timeLimitSec;

      // Mensaje de inicio de turno (para mostrar tentaciones sin revelar autor)
      let startMsg = "";

      // Aplicar penalizaciones pendientes (pecados) al jugador activo (solo 1 vez)
      const activeSeat = (campaignState.players && campaignState.players[campaignState.activePlayerIndex])
        ? campaignState.players[campaignState.activePlayerIndex].id
        : (campaignState.activePlayerIndex + 1);

      
      // Aplicar bonus pendientes (por roles) al jugador activo
      const bonus = (multiplayer && multiplayer.latestRoom && multiplayer.latestRoom.pendingBonuses)
        ? multiplayer.latestRoom.pendingBonuses[String(activeSeat)]
        : null;
      if (bonus) {
        if (bonus.timeDelta) campaignState.timerRemaining = Math.max(0, campaignState.timerRemaining + bonus.timeDelta);
        if (bonus.attemptsDelta) campaignState.attemptsRemaining = Math.max(0, campaignState.attemptsRemaining + bonus.attemptsDelta);

        // limpiar bonus en Firestore (host)
        if (multiplayer.roomRef && appMode !== "player") {
          const fieldB = `pendingBonuses.${activeSeat}`;
          multiplayer.roomRef.update({ [fieldB]: firebase.firestore.FieldValue.delete() }).catch(()=>{});
        }
      }

const pending = (multiplayer && multiplayer.latestRoom && multiplayer.latestRoom.pendingPenalties)
        ? multiplayer.latestRoom.pendingPenalties[String(activeSeat)]
        : null;

      
      if (pending) {
        // Guardar snapshot para posibles ‚Äúclemencias‚Äù
        campaignState.appliedPenaltySnapshot = Object.assign({}, pending);

        if (pending.timeDelta) campaignState.timerRemaining = Math.max(0, campaignState.timerRemaining + pending.timeDelta);
        if (pending.attemptsDelta) campaignState.attemptsRemaining = Math.max(0, campaignState.attemptsRemaining + pending.attemptsDelta);

        if (pending.blockHint1ForSecFromStart) {
          campaignState.blockHint1Until = Date.now() + (pending.blockHint1ForSecFromStart * 1000);
        }
        if (pending.blockHint2ThisTurn) {
          campaignState.hint2HardLocked = true;
        }
        if (pending.verifyLockedWhileRemainingAbove) {
          campaignState.verifyLockedWhileRemainingAbove = pending.verifyLockedWhileRemainingAbove;
        }
        if (pending.wrongPenaltyOverrideSec) {
          campaignState.wrongPenaltyOverrideSec = pending.wrongPenaltyOverrideSec;
        }
        if (pending.wrongExtraAttemptLoss) {
          campaignState.wrongExtraAttemptLoss = true;
        }
        // Mostrar en host SOLO la tentaci√≥n recibida (sin indicar qui√©n la lanz√≥)
        const msgParts = [];
        if (pending.sinKey) msgParts.push(`‚ò†Ô∏è Tentaci√≥n recibida: ${pending.sinKey}.`);
        if (pending.physical) {
          campaignState.activePhysicalPenaltyText = pending.physical;
          msgParts.push(`‚ö†Ô∏è Restricci√≥n: ${pending.physical}`);
        }
        if (msgParts.length) startMsg = msgParts.join(" ");

        // limpiar penalizaci√≥n en Firestore (host)
        if (multiplayer.roomRef && appMode !== "player") {
          const field = `pendingPenalties.${activeSeat}`;
          multiplayer.roomRef.update({ [field]: firebase.firestore.FieldValue.delete() }).catch(()=>{});
        }
      }

      
      // Aplicar bonus/malus de inicio de turno (por roles)
      const _roomDoc = (multiplayer && multiplayer.latestRoom) ? multiplayer.latestRoom : {};
      const _listRoles = (multiplayer && Array.isArray(multiplayer.hostPlayers) && multiplayer.hostPlayers.length)
        ? multiplayer.hostPlayers
        : (multiplayer.playerList || []);
      const _ap = (_listRoles && _listRoles.length) ? (_listRoles.find(p => Number(p.seatNumber) === Number(activeSeat)) || null) : null;
      const activeCmdKey = _ap ? (_ap.commandmentKey || _ap.commandment || _ap.mandamiento) : null;
      const activeSinKey = _ap ? (_ap.sinKey || _ap.sin || _ap.pecado) : null;

      // Mandamiento IX: +10s si el anterior gast√≥ s√≠mbolo en poder
      if (activeCmdKey === "No codiciar√°s bienes ajenos" && _roomDoc.lastTokenType === "power") {
        campaignState.timerRemaining = Math.max(0, campaignState.timerRemaining + 10);
      }

      // Pecados (inicio de turno)
      if (activeSinKey === "Soberbia") {
        campaignState.timerRemaining = Math.max(0, campaignState.timerRemaining + 10);
      }
      if (activeSinKey === "Pereza") {
        campaignState.timerRemaining = Math.max(0, campaignState.timerRemaining - 10);
      }

      // Bloqueos por defecto
      campaignState.activeCmdKey = activeCmdKey || null;
      campaignState.activeSinKey = activeSinKey || null;
updateTimerUI();
      updateAttemptsUI();
      startCampaignTimer();
      refreshHintButtonsUI(puzzle);
      setCampaignStatus(startMsg);
    } else {
      refreshHintButtonsUI(puzzle);
    }
    if (prevBtn) prevBtn.disabled = puzzles.length <= 1;
    if (nextBtn) nextBtn.disabled = false;

    updateSolvedUIForCurrentPuzzle();
  }

  function loadRoom(roomKey, puzzleIndexOverride, opts) {
    opts = opts || {};
    const room = rooms[roomKey];
    if (!room) return;

    const apply = () => {
      currentRoomKey = roomKey;

      const puzzles = room.puzzles || [];
      if (puzzleIndexOverride != null &&
          puzzleIndexOverride >= 0 &&
          puzzleIndexOverride < puzzles.length) {
        currentPuzzleIndex = puzzleIndexOverride;
      } else {
        if (currentPuzzleIndex >= puzzles.length) currentPuzzleIndex = 0;
      }

      if (roomTitleEl) roomTitleEl.textContent = room.name || "";
      if (roomSubtitleEl) roomSubtitleEl.textContent = room.subtitle || "";
      if (roomTaglineEl) roomTaglineEl.textContent = room.tagline || "";
      if (roomImageEl && room.image) {
        roomImageEl.src = room.image;
        roomImageEl.alt = `Ilustraci√≥n de ${room.name || ""}`;
      }

      // Prepara audio de sala (NO lo reproducimos aqu√≠; lo gestiona showRoomSectionImmediate)
      if (roomAudioEl) {
        roomAudioEl.src = room.audio || "";
        roomAudioEl.load();
      }

      // Estado/UI
      setActiveRoomButton(roomKey);
      loadPuzzle();
      updateRoomSolvedSummary();
      updateSidebarRoomCounters();
      updateGlobalSolvedSummary();

      // Campa√±a (host): publica el acertijo activo en Firestore (para que el m√≥vil sepa que est√° resolviendo)
      if (gameMode === "campaign-room" && multiplayer.roomRef && appMode !== "player") {
        try {
          const activeCode = (opts && opts.forcePuzzleCode) ? String(opts.forcePuzzleCode).toUpperCase() :
            (room.puzzles && room.puzzles[currentPuzzleIndex] && room.puzzles[currentPuzzleIndex].id) ? String(room.puzzles[currentPuzzleIndex].id).toUpperCase() :
            (campaignState && campaignState.lastLoadedCode) ? String(campaignState.lastLoadedCode).toUpperCase() : null;
          if (activeCode) {
            multiplayer.roomRef.update({
              currentPuzzleCode: activeCode,
              currentRoomKey: roomKey,
              hint2Unlocked: false,
              turnTokenUsed: false
            }).catch(()=>{});
          }
        } catch (_) {}
      }

      // Mostrar la sala ya dentro de la transici√≥n (evita ‚Äúcambios antes del negro‚Äù)
      showRoomSectionImmediate();
    };

    if (opts.noTransition) apply();
    else transitionTo(apply);
  }

  function findPuzzleByCode(rawCode) {
    if (!rawCode) return null;
    const normalized = rawCode.trim().toUpperCase();
    for (const [key, room] of Object.entries(rooms)) {
      const puzzles = room.puzzles || [];
      const idx = puzzles.findIndex(
        p => p.id && p.id.toUpperCase() === normalized
      );
      if (idx !== -1) {
        return { roomKey: key, index: idx, code: normalized };
      }
    }
    return null;
  }

  // --- LISTENERS ---

  roomButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      const key = btn.dataset.room;
      if (key && key !== currentRoomKey) {
        gameMode = "free";
        loadRoom(key, 0);
      }
    });
  });

	if (musicToggleBtn) {
    // Persistencia simple del estado de m√∫sica general
    try { bgMusicMuted = localStorage.getItem("archivum_bgMusicMuted") === "1"; } catch (_) {}

    const refreshMusicLabel = () => {
      musicToggleBtn.textContent = bgMusicMuted ? "üîá M√∫sica general: OFF" : "üîà M√∫sica general: ON";
    };
    refreshMusicLabel();

    musicToggleBtn.addEventListener("click", () => {
      bgMusicMuted = !bgMusicMuted;
      try { localStorage.setItem("archivum_bgMusicMuted", bgMusicMuted ? "1" : "0"); } catch (_) {}
      refreshMusicLabel();
      if (bgMusicMuted) {
        stopBackgroundMusic();
      } else {
        playBackgroundMusic();
      }
    });

    // Intento de reproducci√≥n al cargar (si el navegador lo permite)
    if (!bgMusicMuted) {
      playBackgroundMusic();
      // Si el navegador bloquea el autoplay con sonido, lo reintentamos al primer gesto del usuario.
      const resumeOnFirstGesture = () => {
        if (!bgMusicMuted) playBackgroundMusic();
      };
      window.addEventListener("pointerdown", resumeOnFirstGesture, { once: true, capture: true });
      window.addEventListener("keydown", resumeOnFirstGesture, { once: true, capture: true });
    }
  }

	const skipBtn = document.getElementById("skipPuzzleBtn");
	if (skipBtn) {
	  skipBtn.addEventListener("click", () => {
		failOrSkipCurrentPuzzle("skip");
	  });
	}

	const failBtn = document.getElementById("failAttemptBtn");
	if (failBtn) {
	  failBtn.addEventListener("click", () => {
		if (gameMode !== "campaign-room" || !campaignState) return;
		campaignState.attemptsRemaining = Math.max(0, (campaignState.attemptsRemaining || 0) - 1);
		updateAttemptsUI();

		// Penalizaci√≥n de tiempo por fallo
		const penalty = (GAME_RULES && GAME_RULES.wrongAttemptTimePenaltySec) ? GAME_RULES.wrongAttemptTimePenaltySec : 30;
		if (campaignState.ignoreNextTimePenaltyOnce) {
		  campaignState.ignoreNextTimePenaltyOnce = false;
		} else {
		  campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) - penalty);
		}
		updateTimerUI();

		if (campaignState.attemptsRemaining <= 0 || campaignState.timerRemaining <= 0) {
		  failOrSkipCurrentPuzzle(campaignState.attemptsRemaining <= 0 ? "attempts" : "timeout");
		}
	  });
	}

	
// --- Respuesta final (verificaci√≥n en host) ---
const answerBar = document.getElementById("answerBar");
const answerInput = document.getElementById("answerInput");
const verifyAnswerBtn = document.getElementById("verifyAnswerBtn");
const manualCorrectBtn = document.getElementById("manualCorrectBtn");
const answerFeedback = document.getElementById("answerFeedback");

function normalizeAnswer(raw) {
  if (raw == null) return "";
  let s = String(raw).trim().toLowerCase();
  // quitar tildes/diacr√≠ticos
  try { s = s.normalize("NFD").replace(/[\u0300-\u036f]/g, ""); } catch (_) {}
  // quitar puntuaci√≥n com√∫n
  s = s.replace(/[\.;:¬°!¬ø\?\(\)\[\]\{\}"]/g, " ");
  s = s.replace(/\s+/g, " ").trim();
  return s;
}

function normalizeNumeric(raw) {
  let s = normalizeAnswer(raw);
  // para n√∫meros con coma decimal
  s = s.replace(/,/g, ".");
  // deja solo n√∫meros, signo y punto
  s = s.replace(/[^0-9\-\.]/g, "");
  // quitar ceros a la izquierda (manteniendo "0" si aplica)
  if (/^-?\d+(?:\.\d+)?$/.test(s)) {
    const num = Number(s);
    if (!Number.isNaN(num)) return String(num);
  }
  return s;
}

function extractFinalAnswerFromSolutionText(solutionText) {
  if (!solutionText) return null;
  const t = String(solutionText);

  // 1) L√≠nea con "C√≥digo final"
  const m = t.match(/c[o√≥]digo\s*final\s*[:=]\s*([^\n\r]+)/i);
  const line = m ? m[1] : null;

  const pickFrom = (str) => {
    if (!str) return null;
    // Preferir √∫ltimo n√∫mero (incluye coma decimal)
    const nums = str.match(/-?\d+(?:[\.,]\d+)?/g);
    if (nums && nums.length) return nums[nums.length - 1];
    // Si no hay n√∫meros, intentar √∫ltima palabra "fuerte"
    const words = str.match(/[A-Z√Å√â√ç√ì√ö√ú√ë]{3,}|[a-z√°√©√≠√≥√∫√º√±]{3,}/g);
    if (words && words.length) return words[words.length - 1];
    return null;
  };

  const candidate = pickFrom(line) || pickFrom(t.split(/\r?\n/).slice(-2).join(" "));
  return candidate ? String(candidate).trim() : null;
}

function getAcceptedAnswersForPuzzle(puzzle) {
  if (!puzzle) return [];
  if (Array.isArray(puzzle.acceptedAnswers) && puzzle.acceptedAnswers.length) return puzzle.acceptedAnswers;
  if (typeof puzzle.answer === "string" && puzzle.answer.trim()) return [puzzle.answer.trim()];
  // fallback: intentar extraer del texto de soluci√≥n
  const extracted = extractFinalAnswerFromSolutionText(puzzle.solution);
  return extracted ? [extracted] : [];
}

function setAnswerFeedback(msg, kind) {
  if (!answerFeedback) return;
  answerFeedback.textContent = msg || "";
  answerFeedback.classList.remove("ok", "bad");
  if (kind === "ok") answerFeedback.classList.add("ok");
  if (kind === "bad") answerFeedback.classList.add("bad");
}

function getCurrentPuzzleSafe() {
  const room = rooms[currentRoomKey];
  const puzzles = room ? (room.puzzles || []) : [];
  if (!puzzles.length) return null;
  return puzzles[currentPuzzleIndex] || null;
}


function applyWrongAnswerPenalty() {
  if (gameMode !== "campaign-room" || !campaignState) return;

  if (!campaignState.turnFlags) {
    campaignState.turnFlags = { verifyCount: 0, hasVerified: false, spentAttempt: false, openedHint1: false, usedHint2Unlock: false, usedPower: false, firstWrongNoTimePenaltyUsed: false };
  }

  // Consumir intentos
  campaignState.turnFlags.spentAttempt = true;
  let attemptLoss = 1;
  if (campaignState.wrongExtraAttemptLoss) attemptLoss += 1;

  campaignState.attemptsRemaining = Math.max(0, (campaignState.attemptsRemaining || 0) - attemptLoss);
  updateAttemptsUI();

  // Penalizaci√≥n de tiempo por fallo
  const basePenalty = (GAME_RULES && GAME_RULES.wrongAttemptTimePenaltySec) ? GAME_RULES.wrongAttemptTimePenaltySec : 30;
  const penalty = (campaignState.wrongPenaltyOverrideSec != null) ? campaignState.wrongPenaltyOverrideSec : basePenalty;

  const cmd = campaignState.activeCmdKey;
  const sin = campaignState.activeSinKey;

  const skipTimePenaltyThisWrong =
    ((cmd === "No tomar√°s el Nombre en vano") || (cmd === "No matar√°s")) &&
    !campaignState.turnFlags.firstWrongNoTimePenaltyUsed;

  if (skipTimePenaltyThisWrong) {
    campaignState.turnFlags.firstWrongNoTimePenaltyUsed = true;
  } else {
    campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) - penalty);
  }

  // Coste P1 (Soberbia): -10s extra al fallar
  if (sin === "Soberbia") {
    campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) - 10);
  }

  // Bendici√≥n M7 (No robar√°s): +10s al primer fallo del turno
  if (cmd === "No robar√°s") {
    if (!campaignState.turnFlags.m7RefundUsed) {
      campaignState.turnFlags.m7RefundUsed = true;
      campaignState.timerRemaining = Math.max(0, (campaignState.timerRemaining || 0) + 10);
    }
  }

  // Milagro M3: recuperar 1 intento tras fallar (solo una vez)
  if (campaignState.restoreAttemptOnWrongOnce) {
    campaignState.restoreAttemptOnWrongOnce = false;
    campaignState.attemptsRemaining = Math.max(0, (campaignState.attemptsRemaining || 0) + 1);
    updateAttemptsUI();
  }

  updateTimerUI();

  if (campaignState.attemptsRemaining <= 0 || campaignState.timerRemaining <= 0) {
    failOrSkipCurrentPuzzle(campaignState.attemptsRemaining <= 0 ? "attempts" : "timeout");
  }
}


function verifyCurrentAnswer() {
  if (appMode === "player") return;
  if (gameMode !== "campaign-room") {
    setAnswerFeedback("La verificaci√≥n solo est√° disponible durante la campa√±a.", "bad");
    return;
  }
  const puzzle = getCurrentPuzzleSafe();
  if (!puzzle || !puzzle.id) return;

  const raw = answerInput ? answerInput.value : "";
  const entered = String(raw || "").trim();
  if (!entered) {
    setAnswerFeedback("Escribe una respuesta antes de verificar.", "bad");
    return;
  }

  // Restricciones de verificaci√≥n (Votos / Tentaciones)
  if (campaignState && campaignState.turnFlags) {
    // Tentaci√≥n Pereza (P7): bloqueo hasta que el reloj baje de X
    if (campaignState.verifyLockedWhileRemainingAbove != null &&
        (campaignState.timerRemaining || 0) > campaignState.verifyLockedWhileRemainingAbove) {
      setAnswerFeedback(`‚õî Verificaci√≥n bloqueada hasta que el reloj baje de ${campaignState.verifyLockedWhileRemainingAbove}s.`, "bad");
      return;
    }

    // Voto M2: no verificar con <20s
    if (campaignState.activeCmdKey === "No tomar√°s el Nombre en vano" &&
        (campaignState.timerRemaining || 0) < 20) {
      setAnswerFeedback("‚õìÔ∏è Voto (M2): no puedes verificar con menos de 20s.", "bad");
      return;
    }

    // Voto M8: solo 1 verificaci√≥n por turno
    if (campaignState.activeCmdKey === "No dar√°s falso testimonio" &&
        (campaignState.turnFlags.verifyCount || 0) >= 1) {
      setAnswerFeedback("‚õìÔ∏è Voto (M8): solo puedes verificar 1 vez por turno.", "bad");
      return;
    }
  }

  // Registrar intento de verificaci√≥n
  if (campaignState && campaignState.turnFlags) {
    campaignState.turnFlags.verifyCount = (campaignState.turnFlags.verifyCount || 0) + 1;
    campaignState.turnFlags.hasVerified = true;
  }


  const accepted = getAcceptedAnswersForPuzzle(puzzle);
  if (!accepted.length) {
    setAnswerFeedback("Este acertijo no tiene respuesta autom√°tica. Usa 'Marcar correcto' o 'Ver soluci√≥n'.", "bad");
    return;
  }

  // comparar (texto normalizado + num√©rico normalizado)
  const strictText = (campaignState && campaignState.activeCmdKey === "No codiciar√°s la pareja del pr√≥jimo" && campaignState.hint2Unlocked);

  const normalizeLenient = (raw) => {
    let s = normalizeAnswer(raw);
    // tolera plural simple
    if (!strictText) {
      s = s.replace(/([a-z√±]{4,})es/g, "$1");
      s = s.replace(/([a-z√±]{4,})s/g, "$1");
    }
    return s;
  };

  const enteredNorm = strictText ? normalizeAnswer(entered) : normalizeLenient(entered);
  const enteredNum = normalizeNumeric(entered);

  let ok = false;
  for (const a of accepted) {
    const aNorm = strictText ? normalizeAnswer(a) : normalizeLenient(a);
    const aNum = normalizeNumeric(a);
    if (enteredNorm && aNorm && enteredNorm === aNorm) { ok = true; break; }
    if (enteredNum && aNum && enteredNum === aNum) { ok = true; break; }
  }

  // Guardar √∫ltima respuesta (para ‚Äúm√°s cerca/m√°s lejos‚Äù)
  if (campaignState) campaignState.lastEnteredAnswerNorm = entered;

  if (ok) {
    setAnswerFeedback("‚úÖ Correcto. Acertijo resuelto.", "ok");
    // si ya estaba resuelto, no togglear
    const id = String(puzzle.id || "").toUpperCase();
    if (solvedMap && solvedMap[id]) return;
    // Bonus/penalizaciones para tu PR√ìXIMO turno (seg√∫n roles)
    if (multiplayer && multiplayer.roomRef && appMode !== "player") {
      const seat = (multiplayer.latestRoom && multiplayer.latestRoom.activeSeatNumber) ? multiplayer.latestRoom.activeSeatNumber : null;
      if (seat) {
        const bonus = {};
        // M3: guardar +10s si terminas con >60s
        if (campaignState.activeCmdKey === "Santificar√°s el descanso" && (campaignState.timerRemaining || 0) > 60) {
          bonus.timeDelta = (bonus.timeDelta || 0) + 10;
        }
        // M3 voto: si usaste Pista 2, siguiente turno -15s
        if (campaignState.activeCmdKey === "Santificar√°s el descanso" && campaignState.turnFlags && campaignState.turnFlags.usedHint2Unlock) {
          bonus.timeDelta = (bonus.timeDelta || 0) - 15;
        }
        // M6: si resuelves sin Pista 2, siguiente turno +1 intento
        if (campaignState.activeCmdKey === "No cometer√°s adulterio" && !campaignState.hint2Unlocked) {
          bonus.attemptsDelta = (bonus.attemptsDelta || 0) + 1;
        }
        // P4 (Envidia) coste: si aciertas, siguiente turno -10s
        if (campaignState.activeSinKey === "Envidia") {
          bonus.timeDelta = (bonus.timeDelta || 0) - 10;
        }

        if (Object.keys(bonus).length) {
          firebase.firestore().runTransaction(async (tx) => {
            const snap = await tx.get(multiplayer.roomRef);
            if (!snap.exists) return;
            const r = snap.data() || {};
            const all = Object.assign({}, r.pendingBonuses || {});
            const cur = Object.assign({}, all[String(seat)] || {});
            all[String(seat)] = Object.assign(cur, bonus);
            tx.update(multiplayer.roomRef, { pendingBonuses: all });
          }).catch(()=>{});
        }
      }
    }

    // esto gestiona campa√±a: progreso + volver a tablero + pasar turno
    toggleSolvedCurrentPuzzle();
  } else {
    setAnswerFeedback("‚ùå Incorrecto. Se consume 1 intento y se aplica penalizaci√≥n.", "bad");
    applyWrongAnswerPenalty();
    if (answerInput) answerInput.select();
  }
}

if (answerBar && appMode === "player") {
  answerBar.style.display = "none";
}

if (verifyAnswerBtn) verifyAnswerBtn.addEventListener("click", verifyCurrentAnswer);
if (answerInput) {
  answerInput.addEventListener("keydown", (ev) => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      verifyCurrentAnswer();
    }
  });
}
if (manualCorrectBtn) {
  manualCorrectBtn.addEventListener("click", () => {
    if (appMode === "player") return;
    // Marca como resuelto usando el flujo existente
    const puzzle = getCurrentPuzzleSafe();
    if (!puzzle || !puzzle.id) return;
    const id = String(puzzle.id || "").toUpperCase();
    if (solvedMap && solvedMap[id]) {
      setAnswerFeedback("Ya estaba resuelto.", "ok");
      return;
    }
    setAnswerFeedback("‚úÖ Marcado correcto (manual).", "ok");
    toggleSolvedCurrentPuzzle();
  });
}


if (sinCarousel) {
	  sinCarousel.addEventListener("click", (ev) => {
		const card = ev.target.closest(".sin-card");
		if (!card || !sinSelectionPlayerId) return;
		if (card.classList.contains("sin-card--taken")) return;
		// Evita errores si este bloque se dispara fuera del modo host
		if (!campaignState || !campaignState.players) return;
		if (appMode === "player") return;

		const chosenSin = card.dataset.sin;
		const player = campaignState.players.find(p => p.id === sinSelectionPlayerId);
		if (!player) return;

		player.sin = chosenSin;
		sinSelectionPlayerId = null;
		sinOverlay.classList.add("sin-overlay--hidden");
		renderPlayersSummary();
	  });
	}

	if (sinOverlayClose) {
	  sinOverlayClose.addEventListener("click", () => {
		sinSelectionPlayerId = null;
		sinOverlay.classList.add("sin-overlay--hidden");
	  });
	}

  if (homeLogo) {
    homeLogo.addEventListener("click", showHome);
  }

  if (startBtn) {
    startBtn.addEventListener("click", showCampaignSetup);
  }

	rolesToBoardBtn.addEventListener("click", () => {
	  // aqu√≠ puedes guardar campaignState en localStorage si quieres
	  showCampaignBoardSection();
	});

	rolesCancelBtn.addEventListener("click", () => {
	  campaignState = null;
	  rolesSection.style.display = "none";
	  // volver a la portada
	  showHome(); // o la funci√≥n que ya uses
	});

  if (exploreBtn) {
    exploreBtn.addEventListener("click", () => {
      gameMode = "free";
      loadRoom("origen", 0);
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", showRules);
  }

  if (rulesBackBtn) {
    rulesBackBtn.addEventListener("click", showHome);
  }

	function createCampaignState() {
	  const numPlayers = Math.max(1, Math.min(7, parseInt(playersCountInput.value, 10) || 1));
	  const puzzlesPerRoom = Math.max(1, Math.min(10, parseInt(puzzlesPerRoomInput.value, 10) || 3));

	  const names = (playersNamesInput.value || "")
		.split(",").map(n => n.trim()).filter(Boolean);

	  const shuffledCmds = shuffle(COMMANDMENTS);

	  const players = [];
	  for (let i = 0; i < numPlayers; i++) {
		const name = names[i] || `Jugador ${i + 1}`;
		const cmdKey = shuffledCmds[i % shuffledCmds.length];

		players.push({
		  id: i + 1,
		  name,
		  commandment: cmdKey,
		  sin: null,
		  solved: 0
		});
	  }

	  const state = {
		puzzlesPerRoom,
		players,

		activePlayerIndex: 0,
		roomSolvedTotals: {},
		solvedAttribution: {},
		lastLoadedCode: null,
		lastLoadedRoomKey: null,

		autoPassTurn: true,     // ‚úÖ coma

			timeLimitSec: (room.timeLimitSec || 180),
		timerEnabled: true,
		timerRemaining: (room.timeLimitSec || 180),
		timerIntervalId: null
	  };

	  // ‚úÖ ahora s√≠ existe
	  state.timerRemaining = state.timeLimitSec;
	  return state;
	}



  


});
</script>

<!-- Overlay recompensa: fragmento del c√≥dice -->
<div id="codexRewardOverlay" aria-hidden="true">
  <div id="codexRewardCard" role="dialog" aria-modal="true">
    <img id="codexRewardImg" alt="Fragmento del C√≥dice" src="" />
    <div id="codexRewardHint">Fragmento del C√≥dice obtenido</div>
    <button id="codexRewardBtn" type="button">Continuar</button>
  </div>
</div>

</body>
</html>
